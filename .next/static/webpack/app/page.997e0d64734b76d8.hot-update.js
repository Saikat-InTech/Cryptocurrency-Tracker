"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/binance-service.ts":
/*!*****************************************!*\
  !*** ./lib/services/binance-service.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinanceService: () => (/* binding */ BinanceService)\n/* harmony export */ });\n// Top cryptocurrencies to track\nconst TOP_CRYPTOS = [\n    {\n        id: \"bitcoin\",\n        symbol: \"BTC\",\n        name: \"Bitcoin\",\n        image: \"btc.png\"\n    },\n    {\n        id: \"ethereum\",\n        symbol: \"ETH\",\n        name: \"Ethereum\",\n        image: \"eth.png\"\n    },\n    {\n        id: \"tether\",\n        symbol: \"USDT\",\n        name: \"Tether\",\n        image: \"usdt.png\"\n    },\n    {\n        id: \"ripple\",\n        symbol: \"XRP\",\n        name: \"XRP\",\n        image: \"xrp.png\"\n    },\n    {\n        id: \"binancecoin\",\n        symbol: \"BNB\",\n        name: \"BNB\",\n        image: \"bnb.png\"\n    },\n    {\n        id: \"solana\",\n        symbol: \"SOL\",\n        name: \"Solana\",\n        image: \"sol.png\"\n    }\n];\nclass BinanceService {\n    // Fetch initial crypto data\n    async getCryptoData() {\n        try {\n            // Fetch current prices\n            const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n            const priceData = await priceResponse.json();\n            // Fetch 24h stats\n            const statsResponse = await fetch(\"https://api.binance.com/api/v3/ticker/24hr\");\n            const statsData = await statsResponse.json();\n            // Map the data to our format\n            return TOP_CRYPTOS.map((crypto)=>{\n                const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                const price = priceData.find((p)=>p.symbol === symbol);\n                const stats = statsData.find((s)=>s.symbol === symbol);\n                // Generate random data for fields not available from Binance API\n                const marketCap = this.getRandomMarketCap(crypto.symbol);\n                const circulatingSupply = this.getRandomSupply(crypto.symbol);\n                const maxSupply = crypto.symbol === \"BTC\" ? 21000000 : crypto.symbol === \"ETH\" ? 0 : this.getRandomMaxSupply(crypto.symbol);\n                return {\n                    id: crypto.id,\n                    name: crypto.name,\n                    symbol: crypto.symbol,\n                    image: crypto.image,\n                    price: Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"0\"),\n                    priceChange1h: this.getRandomPercentage(0.5),\n                    priceChange24h: stats ? Number.parseFloat(stats.priceChangePercent) : this.getRandomPercentage(2),\n                    priceChange7d: this.getRandomPercentage(5),\n                    marketCap,\n                    volume24h: stats ? Number.parseFloat(stats.quoteVolume) : this.getRandomVolume(),\n                    volume24hInCrypto: stats ? Number.parseFloat(stats.volume) : this.getRandomVolume() / Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"1\"),\n                    circulatingSupply,\n                    maxSupply,\n                    sparkline7d: \"/crypto-charts/\".concat(crypto.symbol.toLowerCase(), \".svg\"),\n                    sparklineData: this.generateSparklineData(crypto.symbol, crypto.symbol === \"BTC\" || crypto.symbol === \"ETH\" || crypto.symbol === \"SOL\" ? \"up\" : crypto.symbol === \"USDT\" ? \"volatile\" : \"up\"),\n                    isFavorite: false\n                };\n            });\n        } catch (error) {\n            console.error(\"Error fetching crypto data:\", error);\n            throw error;\n        }\n    }\n    // Start WebSocket connection for real-time updates\n    startRealTimeUpdates(callback) {\n        // Create a WebSocket connection to Binance\n        const streams = this.symbols.map((symbol)=>\"\".concat(symbol, \"@ticker\")).join(\"/\");\n        this.websocket = new WebSocket(\"wss://stream.binance.com:9443/ws/\".concat(streams));\n        this.websocket.onmessage = (event)=>{\n            const data = JSON.parse(event.data);\n            // Find the corresponding crypto\n            const symbol = data.s.replace(\"USDT\", \"\");\n            const crypto = TOP_CRYPTOS.find((c)=>c.symbol === symbol);\n            if (crypto) {\n                // Update the crypto data\n                callback({\n                    id: crypto.id,\n                    price: Number.parseFloat(data.c),\n                    priceChange24h: Number.parseFloat(data.P),\n                    priceChange1h: this.getRandomPercentage(0.3),\n                    volume24h: Number.parseFloat(data.q),\n                    volume24hInCrypto: Number.parseFloat(data.v)\n                });\n            }\n        };\n        this.websocket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            // Fallback to polling if WebSocket fails\n            this.startPolling(callback);\n        };\n        // Return a function to stop the WebSocket\n        return ()=>{\n            if (this.websocket) {\n                this.websocket.close();\n                this.websocket = null;\n            }\n        };\n    }\n    // Fallback to polling if WebSocket is not available\n    startPolling(callback) {\n        const interval = setInterval(async ()=>{\n            try {\n                const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n                const priceData = await priceResponse.json();\n                TOP_CRYPTOS.forEach((crypto)=>{\n                    const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                    const price = priceData.find((p)=>p.symbol === symbol);\n                    if (price) {\n                        callback({\n                            id: crypto.id,\n                            price: Number.parseFloat(price.price),\n                            priceChange1h: this.getRandomPercentage(0.3),\n                            priceChange24h: this.getRandomPercentage(1)\n                        });\n                    }\n                });\n            } catch (error) {\n                console.error(\"Error polling crypto data:\", error);\n            }\n        }, 2000);\n        return ()=>clearInterval(interval);\n    }\n    // Helper methods to generate random data\n    getRandomPercentage(max) {\n        return Math.random() * max * 2 - max;\n    }\n    getRandomVolume() {\n        return Math.random() * 10000000000;\n    }\n    getRandomMarketCap(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 1800000000000 + Math.random() * 100000000000;\n            case \"ETH\":\n                return 210000000000 + Math.random() * 10000000000;\n            case \"USDT\":\n                return 140000000000 + Math.random() * 5000000000;\n            case \"XRP\":\n                return 130000000000 + Math.random() * 5000000000;\n            case \"BNB\":\n                return 85000000000 + Math.random() * 2000000000;\n            case \"SOL\":\n                return 78000000000 + Math.random() * 2000000000;\n            default:\n                return 10000000000 + Math.random() * 1000000000;\n        }\n    }\n    getRandomSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 19850000;\n            case \"ETH\":\n                return 120710000;\n            case \"USDT\":\n                return 145270000000;\n            case \"XRP\":\n                return 58390000000;\n            case \"BNB\":\n                return 140890000;\n            case \"SOL\":\n                return 517310000;\n            default:\n                return 1000000000;\n        }\n    }\n    getRandomMaxSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 21000000;\n            case \"XRP\":\n                return 100000000000;\n            case \"BNB\":\n                return 200000000;\n            case \"SOL\":\n                return 700000000;\n            default:\n                return 0;\n        }\n    }\n    generateSparklineData(symbol, trend) {\n        const length = 24;\n        const result = [];\n        let value = 100;\n        for(let i = 0; i < length; i++){\n            if (trend === \"up\") {\n                // Upward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.03 - 0.01));\n            } else if (trend === \"down\") {\n                // Downward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.02 - 0.03));\n            } else {\n                // Volatile with larger fluctuations\n                value = value * (1 + (Math.random() * 0.08 - 0.04));\n            }\n            result.push(value);\n        }\n        return result;\n    }\n    constructor(){\n        this.websocket = null;\n        this.symbols = TOP_CRYPTOS.map((crypto)=>\"\".concat(crypto.symbol.toLowerCase(), \"usdt\"));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9iaW5hbmNlLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBLGdDQUFnQztBQUNoQyxNQUFNQSxjQUFjO0lBQ2xCO1FBQUVDLElBQUk7UUFBV0MsUUFBUTtRQUFPQyxNQUFNO1FBQVdDLE9BQU87SUFBVTtJQUNsRTtRQUFFSCxJQUFJO1FBQVlDLFFBQVE7UUFBT0MsTUFBTTtRQUFZQyxPQUFPO0lBQVU7SUFDcEU7UUFBRUgsSUFBSTtRQUFVQyxRQUFRO1FBQVFDLE1BQU07UUFBVUMsT0FBTztJQUFXO0lBQ2xFO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFPQyxNQUFNO1FBQU9DLE9BQU87SUFBVTtJQUM3RDtRQUFFSCxJQUFJO1FBQWVDLFFBQVE7UUFBT0MsTUFBTTtRQUFPQyxPQUFPO0lBQVU7SUFDbEU7UUFBRUgsSUFBSTtRQUFVQyxRQUFRO1FBQU9DLE1BQU07UUFBVUMsT0FBTztJQUFVO0NBQ2pFO0FBRU0sTUFBTUM7SUFJWCw0QkFBNEI7SUFDNUIsTUFBTUMsZ0JBQXVDO1FBQzNDLElBQUk7WUFDRix1QkFBdUI7WUFDdkIsTUFBTUMsZ0JBQWdCLE1BQU1DLE1BQU07WUFDbEMsTUFBTUMsWUFBWSxNQUFNRixjQUFjRyxJQUFJO1lBRTFDLGtCQUFrQjtZQUNsQixNQUFNQyxnQkFBZ0IsTUFBTUgsTUFBTTtZQUNsQyxNQUFNSSxZQUFZLE1BQU1ELGNBQWNELElBQUk7WUFFMUMsNkJBQTZCO1lBQzdCLE9BQU9WLFlBQVlhLEdBQUcsQ0FBQyxDQUFDQztnQkFDdEIsTUFBTVosU0FBUyxHQUFpQixPQUFkWSxPQUFPWixNQUFNLEVBQUM7Z0JBQ2hDLE1BQU1hLFFBQVFOLFVBQVVPLElBQUksQ0FBQyxDQUFDQyxJQUFXQSxFQUFFZixNQUFNLEtBQUtBO2dCQUN0RCxNQUFNZ0IsUUFBUU4sVUFBVUksSUFBSSxDQUFDLENBQUNHLElBQVdBLEVBQUVqQixNQUFNLEtBQUtBO2dCQUV0RCxpRUFBaUU7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QVUsTUFBTTtnQkFDbEIsdUNBQXVDO2dCQUN2Q0csUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQsT0FBTyxJQUFJQyxVQUFVLFFBQVE7Z0JBQzNCLHlDQUF5QztnQkFDekNHLFFBQVFBLFFBQVMsS0FBS0wsQ0FBQUEsS0FBS0MsTUFBTSxLQUFLLE9BQU8sSUFBRyxDQUFDO1lBQ25ELE9BQU87Z0JBQ0wsb0NBQW9DO2dCQUNwQ0ksUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQ7WUFDQUcsT0FBT0csSUFBSSxDQUFDRjtRQUNkO1FBRUEsT0FBT0Q7SUFDVDs7YUFuTlF4QixZQUE4QjthQUM5QkYsVUFBb0JoRCxZQUFZYSxHQUFHLENBQUMsQ0FBQ0MsU0FBVyxHQUErQixPQUE1QkEsT0FBT1osTUFBTSxDQUFDcUMsV0FBVyxJQUFHOztBQW1OekYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcOTE2MjlcXERvd25sb2Fkc1xcY3J5cHRvLWRhc2hib2FyZFxcbGliXFxzZXJ2aWNlc1xcYmluYW5jZS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ3J5cHRvRGF0YSB9IGZyb20gXCJAL2xpYi90eXBlc1wiXG5cbi8vIFRvcCBjcnlwdG9jdXJyZW5jaWVzIHRvIHRyYWNrXG5jb25zdCBUT1BfQ1JZUFRPUyA9IFtcbiAgeyBpZDogXCJiaXRjb2luXCIsIHN5bWJvbDogXCJCVENcIiwgbmFtZTogXCJCaXRjb2luXCIsIGltYWdlOiBcImJ0Yy5wbmdcIiB9LFxuICB7IGlkOiBcImV0aGVyZXVtXCIsIHN5bWJvbDogXCJFVEhcIiwgbmFtZTogXCJFdGhlcmV1bVwiLCBpbWFnZTogXCJldGgucG5nXCIgfSxcbiAgeyBpZDogXCJ0ZXRoZXJcIiwgc3ltYm9sOiBcIlVTRFRcIiwgbmFtZTogXCJUZXRoZXJcIiwgaW1hZ2U6IFwidXNkdC5wbmdcIiB9LFxuICB7IGlkOiBcInJpcHBsZVwiLCBzeW1ib2w6IFwiWFJQXCIsIG5hbWU6IFwiWFJQXCIsIGltYWdlOiBcInhycC5wbmdcIiB9LFxuICB7IGlkOiBcImJpbmFuY2Vjb2luXCIsIHN5bWJvbDogXCJCTkJcIiwgbmFtZTogXCJCTkJcIiwgaW1hZ2U6IFwiYm5iLnBuZ1wiIH0sXG4gIHsgaWQ6IFwic29sYW5hXCIsIHN5bWJvbDogXCJTT0xcIiwgbmFtZTogXCJTb2xhbmFcIiwgaW1hZ2U6IFwic29sLnBuZ1wiIH0sXG5dXG5cbmV4cG9ydCBjbGFzcyBCaW5hbmNlU2VydmljZSB7XG4gIHByaXZhdGUgd2Vic29ja2V0OiBXZWJTb2NrZXQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHN5bWJvbHM6IHN0cmluZ1tdID0gVE9QX0NSWVBUT1MubWFwKChjcnlwdG8pID0+IGAke2NyeXB0by5zeW1ib2wudG9Mb3dlckNhc2UoKX11c2R0YClcblxuICAvLyBGZXRjaCBpbml0aWFsIGNyeXB0byBkYXRhXG4gIGFzeW5jIGdldENyeXB0b0RhdGEoKTogUHJvbWlzZTxDcnlwdG9EYXRhW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggY3VycmVudCBwcmljZXNcbiAgICAgIGNvbnN0IHByaWNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92My90aWNrZXIvcHJpY2VcIilcbiAgICAgIGNvbnN0IHByaWNlRGF0YSA9IGF3YWl0IHByaWNlUmVzcG9uc2UuanNvbigpXG5cbiAgICAgIC8vIEZldGNoIDI0aCBzdGF0c1xuICAgICAgY29uc3Qgc3RhdHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzL3RpY2tlci8yNGhyXCIpXG4gICAgICBjb25zdCBzdGF0c0RhdGEgPSBhd2FpdCBzdGF0c1Jlc3BvbnNlLmpzb24oKVxuXG4gICAgICAvLyBNYXAgdGhlIGRhdGEgdG8gb3VyIGZvcm1hdFxuICAgICAgcmV0dXJuIFRPUF9DUllQVE9TLm1hcCgoY3J5cHRvKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGAke2NyeXB0by5zeW1ib2x9VVNEVGBcbiAgICAgICAgY29uc3QgcHJpY2UgPSBwcmljZURhdGEuZmluZCgocDogYW55KSA9PiBwLnN5bWJvbCA9PT0gc3ltYm9sKVxuICAgICAgICBjb25zdCBzdGF0cyA9IHN0YXRzRGF0YS5maW5kKChzOiBhbnkpID0+IHMuc3ltYm9sID09PSBzeW1ib2wpXG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIGRhdGEgZm9yIGZpZWxkcyBub3QgYXZhaWxhYmxlIGZyb20gQmluYW5jZSBBUElcbiAgICAgICAgY29uc3QgbWFya2V0Q2FwID0gdGhpcy5nZXRSYW5kb21NYXJrZXRDYXAoY3J5cHRvLnN5bWJvbClcbiAgICAgICAgY29uc3QgY2lyY3VsYXRpbmdTdXBwbHkgPSB0aGlzLmdldFJhbmRvbVN1cHBseShjcnlwdG8uc3ltYm9sKVxuICAgICAgICBjb25zdCBtYXhTdXBwbHkgPVxuICAgICAgICAgIGNyeXB0by5zeW1ib2wgPT09IFwiQlRDXCIgPyAyMTAwMDAwMCA6IGNyeXB0by5zeW1ib2wgPT09IFwiRVRIXCIgPyAwIDogdGhpcy5nZXRSYW5kb21NYXhTdXBwbHkoY3J5cHRvLnN5bWJvbClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBjcnlwdG8uaWQsXG4gICAgICAgICAgbmFtZTogY3J5cHRvLm5hbWUsXG4gICAgICAgICAgc3ltYm9sOiBjcnlwdG8uc3ltYm9sLFxuICAgICAgICAgIGltYWdlOiBjcnlwdG8uaW1hZ2UsXG4gICAgICAgICAgcHJpY2U6IE51bWJlci5wYXJzZUZsb2F0KHByaWNlPy5wcmljZSB8fCBcIjBcIiksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UxaDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDAuNSksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IHN0YXRzID8gTnVtYmVyLnBhcnNlRmxvYXQoc3RhdHMucHJpY2VDaGFuZ2VQZXJjZW50KSA6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgyKSxcbiAgICAgICAgICBwcmljZUNoYW5nZTdkOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoNSksXG4gICAgICAgICAgbWFya2V0Q2FwLFxuICAgICAgICAgIHZvbHVtZTI0aDogc3RhdHMgPyBOdW1iZXIucGFyc2VGbG9hdChzdGF0cy5xdW90ZVZvbHVtZSkgOiB0aGlzLmdldFJhbmRvbVZvbHVtZSgpLFxuICAgICAgICAgIHZvbHVtZTI0aEluQ3J5cHRvOiBzdGF0c1xuICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdChzdGF0cy52b2x1bWUpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0UmFuZG9tVm9sdW1lKCkgLyBOdW1iZXIucGFyc2VGbG9hdChwcmljZT8ucHJpY2UgfHwgXCIxXCIpLFxuICAgICAgICAgIGNpcmN1bGF0aW5nU3VwcGx5LFxuICAgICAgICAgIG1heFN1cHBseSxcbiAgICAgICAgICBzcGFya2xpbmU3ZDogYC9jcnlwdG8tY2hhcnRzLyR7Y3J5cHRvLnN5bWJvbC50b0xvd2VyQ2FzZSgpfS5zdmdgLFxuICAgICAgICAgIHNwYXJrbGluZURhdGE6IHRoaXMuZ2VuZXJhdGVTcGFya2xpbmVEYXRhKFxuICAgICAgICAgICAgY3J5cHRvLnN5bWJvbCxcbiAgICAgICAgICAgIGNyeXB0by5zeW1ib2wgPT09IFwiQlRDXCIgfHwgY3J5cHRvLnN5bWJvbCA9PT0gXCJFVEhcIiB8fCBjcnlwdG8uc3ltYm9sID09PSBcIlNPTFwiXG4gICAgICAgICAgICAgID8gXCJ1cFwiXG4gICAgICAgICAgICAgIDogY3J5cHRvLnN5bWJvbCA9PT0gXCJVU0RUXCJcbiAgICAgICAgICAgICAgICA/IFwidm9sYXRpbGVcIlxuICAgICAgICAgICAgICAgIDogXCJ1cFwiLFxuICAgICAgICAgICksXG4gICAgICAgICAgaXNGYXZvcml0ZTogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjcnlwdG8gZGF0YTpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXJ0IFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICBzdGFydFJlYWxUaW1lVXBkYXRlcyhjYWxsYmFjazogKHVwZGF0ZTogUGFydGlhbDxDcnlwdG9EYXRhPiAmIHsgaWQ6IHN0cmluZyB9KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgLy8gQ3JlYXRlIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gQmluYW5jZVxuICAgIGNvbnN0IHN0cmVhbXMgPSB0aGlzLnN5bWJvbHMubWFwKChzeW1ib2wpID0+IGAke3N5bWJvbH1AdGlja2VyYCkuam9pbihcIi9cIilcbiAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQoYHdzczovL3N0cmVhbS5iaW5hbmNlLmNvbTo5NDQzL3dzLyR7c3RyZWFtc31gKVxuXG4gICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuXG4gICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGNyeXB0b1xuICAgICAgY29uc3Qgc3ltYm9sID0gZGF0YS5zLnJlcGxhY2UoXCJVU0RUXCIsIFwiXCIpXG4gICAgICBjb25zdCBjcnlwdG8gPSBUT1BfQ1JZUFRPUy5maW5kKChjKSA9PiBjLnN5bWJvbCA9PT0gc3ltYm9sKVxuXG4gICAgICBpZiAoY3J5cHRvKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3J5cHRvIGRhdGFcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIGlkOiBjcnlwdG8uaWQsXG4gICAgICAgICAgcHJpY2U6IE51bWJlci5wYXJzZUZsb2F0KGRhdGEuYyksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IE51bWJlci5wYXJzZUZsb2F0KGRhdGEuUCksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UxaDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDAuMyksIC8vIFNpbXVsYXRlIDFoIGNoYW5nZVxuICAgICAgICAgIHZvbHVtZTI0aDogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS5xKSxcbiAgICAgICAgICB2b2x1bWUyNGhJbkNyeXB0bzogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS52KSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IGVycm9yOlwiLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgV2ViU29ja2V0IGZhaWxzXG4gICAgICB0aGlzLnN0YXJ0UG9sbGluZyhjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0byBzdG9wIHRoZSBXZWJTb2NrZXRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud2Vic29ja2V0KSB7XG4gICAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKClcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiBXZWJTb2NrZXQgaXMgbm90IGF2YWlsYWJsZVxuICBwcml2YXRlIHN0YXJ0UG9sbGluZyhjYWxsYmFjazogKHVwZGF0ZTogUGFydGlhbDxDcnlwdG9EYXRhPiAmIHsgaWQ6IHN0cmluZyB9KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcmljZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjMvdGlja2VyL3ByaWNlXCIpXG4gICAgICAgIGNvbnN0IHByaWNlRGF0YSA9IGF3YWl0IHByaWNlUmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgVE9QX0NSWVBUT1MuZm9yRWFjaCgoY3J5cHRvKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gYCR7Y3J5cHRvLnN5bWJvbH1VU0RUYFxuICAgICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VEYXRhLmZpbmQoKHA6IGFueSkgPT4gcC5zeW1ib2wgPT09IHN5bWJvbClcblxuICAgICAgICAgIGlmIChwcmljZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICBpZDogY3J5cHRvLmlkLFxuICAgICAgICAgICAgICBwcmljZTogTnVtYmVyLnBhcnNlRmxvYXQocHJpY2UucHJpY2UpLFxuICAgICAgICAgICAgICBwcmljZUNoYW5nZTFoOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMC4zKSxcbiAgICAgICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgxKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBvbGxpbmcgY3J5cHRvIGRhdGE6XCIsIGVycm9yKVxuICAgICAgfVxuICAgIH0sIDIwMDApXG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzIHRvIGdlbmVyYXRlIHJhbmRvbSBkYXRhXG4gIHByaXZhdGUgZ2V0UmFuZG9tUGVyY2VudGFnZShtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBtYXggKiAyIC0gbWF4XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVZvbHVtZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDBcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmFuZG9tTWFya2V0Q2FwKHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBcIkJUQ1wiOlxuICAgICAgICByZXR1cm4gMTgwMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJFVEhcIjpcbiAgICAgICAgcmV0dXJuIDIxMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMFxuICAgICAgY2FzZSBcIlVTRFRcIjpcbiAgICAgICAgcmV0dXJuIDE0MDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA1MDAwMDAwMDAwXG4gICAgICBjYXNlIFwiWFJQXCI6XG4gICAgICAgIHJldHVybiAxMzAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogNTAwMDAwMDAwMFxuICAgICAgY2FzZSBcIkJOQlwiOlxuICAgICAgICByZXR1cm4gODUwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMjAwMDAwMDAwMFxuICAgICAgY2FzZSBcIlNPTFwiOlxuICAgICAgICByZXR1cm4gNzgwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMjAwMDAwMDAwMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDBcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVN1cHBseShzeW1ib2w6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgXCJCVENcIjpcbiAgICAgICAgcmV0dXJuIDE5ODUwMDAwXG4gICAgICBjYXNlIFwiRVRIXCI6XG4gICAgICAgIHJldHVybiAxMjA3MTAwMDBcbiAgICAgIGNhc2UgXCJVU0RUXCI6XG4gICAgICAgIHJldHVybiAxNDUyNzAwMDAwMDBcbiAgICAgIGNhc2UgXCJYUlBcIjpcbiAgICAgICAgcmV0dXJuIDU4MzkwMDAwMDAwXG4gICAgICBjYXNlIFwiQk5CXCI6XG4gICAgICAgIHJldHVybiAxNDA4OTAwMDBcbiAgICAgIGNhc2UgXCJTT0xcIjpcbiAgICAgICAgcmV0dXJuIDUxNzMxMDAwMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDBcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbU1heFN1cHBseShzeW1ib2w6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgXCJCVENcIjpcbiAgICAgICAgcmV0dXJuIDIxMDAwMDAwXG4gICAgICBjYXNlIFwiWFJQXCI6XG4gICAgICAgIHJldHVybiAxMDAwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJCTkJcIjpcbiAgICAgICAgcmV0dXJuIDIwMDAwMDAwMFxuICAgICAgY2FzZSBcIlNPTFwiOlxuICAgICAgICByZXR1cm4gNzAwMDAwMDAwXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVTcGFya2xpbmVEYXRhKHN5bWJvbDogc3RyaW5nLCB0cmVuZDogXCJ1cFwiIHwgXCJkb3duXCIgfCBcInZvbGF0aWxlXCIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbGVuZ3RoID0gMjRcbiAgICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW11cbiAgICBsZXQgdmFsdWUgPSAxMDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVuZCA9PT0gXCJ1cFwiKSB7XG4gICAgICAgIC8vIFVwd2FyZCB0cmVuZCB3aXRoIHNtYWxsIGZsdWN0dWF0aW9uc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDMgLSAwLjAxKSlcbiAgICAgIH0gZWxzZSBpZiAodHJlbmQgPT09IFwiZG93blwiKSB7XG4gICAgICAgIC8vIERvd253YXJkIHRyZW5kIHdpdGggc21hbGwgZmx1Y3R1YXRpb25zXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wMiAtIDAuMDMpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVm9sYXRpbGUgd2l0aCBsYXJnZXIgZmx1Y3R1YXRpb25zXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wOCAtIDAuMDQpKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG4iXSwibmFtZXMiOlsiVE9QX0NSWVBUT1MiLCJpZCIsInN5bWJvbCIsIm5hbWUiLCJpbWFnZSIsIkJpbmFuY2VTZXJ2aWNlIiwiZ2V0Q3J5cHRvRGF0YSIsInByaWNlUmVzcG9uc2UiLCJmZXRjaCIsInByaWNlRGF0YSIsImpzb24iLCJzdGF0c1Jlc3BvbnNlIiwic3RhdHNEYXRhIiwibWFwIiwiY3J5cHRvIiwicHJpY2UiLCJmaW5kIiwicCIsInN0YXRzIiwicyIsIm1hcmtldENhcCIsImdldFJhbmRvbU1hcmtldENhcCIsImNpcmN1bGF0aW5nU3VwcGx5IiwiZ2V0UmFuZG9tU3VwcGx5IiwibWF4U3VwcGx5IiwiZ2V0UmFuZG9tTWF4U3VwcGx5IiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInByaWNlQ2hhbmdlMWgiLCJnZXRSYW5kb21QZXJjZW50YWdlIiwicHJpY2VDaGFuZ2UyNGgiLCJwcmljZUNoYW5nZVBlcmNlbnQiLCJwcmljZUNoYW5nZTdkIiwidm9sdW1lMjRoIiwicXVvdGVWb2x1bWUiLCJnZXRSYW5kb21Wb2x1bWUiLCJ2b2x1bWUyNGhJbkNyeXB0byIsInZvbHVtZSIsInNwYXJrbGluZTdkIiwidG9Mb3dlckNhc2UiLCJzcGFya2xpbmVEYXRhIiwiZ2VuZXJhdGVTcGFya2xpbmVEYXRhIiwiaXNGYXZvcml0ZSIsImVycm9yIiwiY29uc29sZSIsInN0YXJ0UmVhbFRpbWVVcGRhdGVzIiwiY2FsbGJhY2siLCJzdHJlYW1zIiwic3ltYm9scyIsImpvaW4iLCJ3ZWJzb2NrZXQiLCJXZWJTb2NrZXQiLCJvbm1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJyZXBsYWNlIiwiYyIsIlAiLCJxIiwidiIsIm9uZXJyb3IiLCJzdGFydFBvbGxpbmciLCJjbG9zZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJmb3JFYWNoIiwiY2xlYXJJbnRlcnZhbCIsIm1heCIsIk1hdGgiLCJyYW5kb20iLCJ0cmVuZCIsImxlbmd0aCIsInJlc3VsdCIsInZhbHVlIiwiaSIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/binance-service.ts\n"));

/***/ })

});
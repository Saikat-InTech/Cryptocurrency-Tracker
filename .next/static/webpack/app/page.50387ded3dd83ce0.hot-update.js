"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/binance-service.ts":
/*!*****************************************!*\
  !*** ./lib/services/binance-service.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinanceService: () => (/* binding */ BinanceService)\n/* harmony export */ });\n// Top cryptocurrencies to track\nconst TOP_CRYPTOS = [\n    {\n        id: \"bitcoin\",\n        symbol: \"BTC\",\n        name: \"Bitcoin\",\n        image: \"btc.png\"\n    },\n    {\n        id: \"ethereum\",\n        symbol: \"ETH\",\n        name: \"Ethereum\",\n        image: \"/crypto-icons/eth.png\"\n    },\n    {\n        id: \"tether\",\n        symbol: \"USDT\",\n        name: \"Tether\",\n        image: \"/crypto-icons/usdt.png\"\n    },\n    {\n        id: \"ripple\",\n        symbol: \"XRP\",\n        name: \"XRP\",\n        image: \"/crypto-icons/xrp.png\"\n    },\n    {\n        id: \"binancecoin\",\n        symbol: \"BNB\",\n        name: \"BNB\",\n        image: \"/crypto-icons/bnb.png\"\n    },\n    {\n        id: \"solana\",\n        symbol: \"SOL\",\n        name: \"Solana\",\n        image: \"/crypto-icons/sol.png\"\n    }\n];\nclass BinanceService {\n    // Fetch initial crypto data\n    async getCryptoData() {\n        try {\n            // Fetch current prices\n            const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n            const priceData = await priceResponse.json();\n            // Fetch 24h stats\n            const statsResponse = await fetch(\"https://api.binance.com/api/v3/ticker/24hr\");\n            const statsData = await statsResponse.json();\n            // Map the data to our format\n            return TOP_CRYPTOS.map((crypto)=>{\n                const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                const price = priceData.find((p)=>p.symbol === symbol);\n                const stats = statsData.find((s)=>s.symbol === symbol);\n                // Generate random data for fields not available from Binance API\n                const marketCap = this.getRandomMarketCap(crypto.symbol);\n                const circulatingSupply = this.getRandomSupply(crypto.symbol);\n                const maxSupply = crypto.symbol === \"BTC\" ? 21000000 : crypto.symbol === \"ETH\" ? 0 : this.getRandomMaxSupply(crypto.symbol);\n                return {\n                    id: crypto.id,\n                    name: crypto.name,\n                    symbol: crypto.symbol,\n                    image: crypto.image,\n                    price: Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"0\"),\n                    priceChange1h: this.getRandomPercentage(0.5),\n                    priceChange24h: stats ? Number.parseFloat(stats.priceChangePercent) : this.getRandomPercentage(2),\n                    priceChange7d: this.getRandomPercentage(5),\n                    marketCap,\n                    volume24h: stats ? Number.parseFloat(stats.quoteVolume) : this.getRandomVolume(),\n                    volume24hInCrypto: stats ? Number.parseFloat(stats.volume) : this.getRandomVolume() / Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"1\"),\n                    circulatingSupply,\n                    maxSupply,\n                    sparkline7d: \"/crypto-charts/\".concat(crypto.symbol.toLowerCase(), \".svg\"),\n                    sparklineData: this.generateSparklineData(crypto.symbol, crypto.symbol === \"BTC\" || crypto.symbol === \"ETH\" || crypto.symbol === \"SOL\" ? \"up\" : crypto.symbol === \"USDT\" ? \"volatile\" : \"up\"),\n                    isFavorite: false\n                };\n            });\n        } catch (error) {\n            console.error(\"Error fetching crypto data:\", error);\n            throw error;\n        }\n    }\n    // Start WebSocket connection for real-time updates\n    startRealTimeUpdates(callback) {\n        // Create a WebSocket connection to Binance\n        const streams = this.symbols.map((symbol)=>\"\".concat(symbol, \"@ticker\")).join(\"/\");\n        this.websocket = new WebSocket(\"wss://stream.binance.com:9443/ws/\".concat(streams));\n        this.websocket.onmessage = (event)=>{\n            const data = JSON.parse(event.data);\n            // Find the corresponding crypto\n            const symbol = data.s.replace(\"USDT\", \"\");\n            const crypto = TOP_CRYPTOS.find((c)=>c.symbol === symbol);\n            if (crypto) {\n                // Update the crypto data\n                callback({\n                    id: crypto.id,\n                    price: Number.parseFloat(data.c),\n                    priceChange24h: Number.parseFloat(data.P),\n                    priceChange1h: this.getRandomPercentage(0.3),\n                    volume24h: Number.parseFloat(data.q),\n                    volume24hInCrypto: Number.parseFloat(data.v)\n                });\n            }\n        };\n        this.websocket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            // Fallback to polling if WebSocket fails\n            this.startPolling(callback);\n        };\n        // Return a function to stop the WebSocket\n        return ()=>{\n            if (this.websocket) {\n                this.websocket.close();\n                this.websocket = null;\n            }\n        };\n    }\n    // Fallback to polling if WebSocket is not available\n    startPolling(callback) {\n        const interval = setInterval(async ()=>{\n            try {\n                const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n                const priceData = await priceResponse.json();\n                TOP_CRYPTOS.forEach((crypto)=>{\n                    const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                    const price = priceData.find((p)=>p.symbol === symbol);\n                    if (price) {\n                        callback({\n                            id: crypto.id,\n                            price: Number.parseFloat(price.price),\n                            priceChange1h: this.getRandomPercentage(0.3),\n                            priceChange24h: this.getRandomPercentage(1)\n                        });\n                    }\n                });\n            } catch (error) {\n                console.error(\"Error polling crypto data:\", error);\n            }\n        }, 2000);\n        return ()=>clearInterval(interval);\n    }\n    // Helper methods to generate random data\n    getRandomPercentage(max) {\n        return Math.random() * max * 2 - max;\n    }\n    getRandomVolume() {\n        return Math.random() * 10000000000;\n    }\n    getRandomMarketCap(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 1800000000000 + Math.random() * 100000000000;\n            case \"ETH\":\n                return 210000000000 + Math.random() * 10000000000;\n            case \"USDT\":\n                return 140000000000 + Math.random() * 5000000000;\n            case \"XRP\":\n                return 130000000000 + Math.random() * 5000000000;\n            case \"BNB\":\n                return 85000000000 + Math.random() * 2000000000;\n            case \"SOL\":\n                return 78000000000 + Math.random() * 2000000000;\n            default:\n                return 10000000000 + Math.random() * 1000000000;\n        }\n    }\n    getRandomSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 19850000;\n            case \"ETH\":\n                return 120710000;\n            case \"USDT\":\n                return 145270000000;\n            case \"XRP\":\n                return 58390000000;\n            case \"BNB\":\n                return 140890000;\n            case \"SOL\":\n                return 517310000;\n            default:\n                return 1000000000;\n        }\n    }\n    getRandomMaxSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 21000000;\n            case \"XRP\":\n                return 100000000000;\n            case \"BNB\":\n                return 200000000;\n            case \"SOL\":\n                return 700000000;\n            default:\n                return 0;\n        }\n    }\n    generateSparklineData(symbol, trend) {\n        const length = 24;\n        const result = [];\n        let value = 100;\n        for(let i = 0; i < length; i++){\n            if (trend === \"up\") {\n                // Upward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.03 - 0.01));\n            } else if (trend === \"down\") {\n                // Downward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.02 - 0.03));\n            } else {\n                // Volatile with larger fluctuations\n                value = value * (1 + (Math.random() * 0.08 - 0.04));\n            }\n            result.push(value);\n        }\n        return result;\n    }\n    constructor(){\n        this.websocket = null;\n        this.symbols = TOP_CRYPTOS.map((crypto)=>\"\".concat(crypto.symbol.toLowerCase(), \"usdt\"));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9iaW5hbmNlLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBLGdDQUFnQztBQUNoQyxNQUFNQSxjQUFjO0lBQ2xCO1FBQUVDLElBQUk7UUFBV0MsUUFBUTtRQUFPQyxNQUFNO1FBQVdDLE9BQU87SUFBVTtJQUNsRTtRQUFFSCxJQUFJO1FBQVlDLFFBQVE7UUFBT0MsTUFBTTtRQUFZQyxPQUFPO0lBQXdCO0lBQ2xGO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFRQyxNQUFNO1FBQVVDLE9BQU87SUFBeUI7SUFDaEY7UUFBRUgsSUFBSTtRQUFVQyxRQUFRO1FBQU9DLE1BQU07UUFBT0MsT0FBTztJQUF3QjtJQUMzRTtRQUFFSCxJQUFJO1FBQWVDLFFBQVE7UUFBT0MsTUFBTTtRQUFPQyxPQUFPO0lBQXdCO0lBQ2hGO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFPQyxNQUFNO1FBQVVDLE9BQU87SUFBd0I7Q0FDL0U7QUFFTSxNQUFNQztJQUlYLDRCQUE0QjtJQUM1QixNQUFNQyxnQkFBdUM7UUFDM0MsSUFBSTtZQUNGLHVCQUF1QjtZQUN2QixNQUFNQyxnQkFBZ0IsTUFBTUMsTUFBTTtZQUNsQyxNQUFNQyxZQUFZLE1BQU1GLGNBQWNHLElBQUk7WUFFMUMsa0JBQWtCO1lBQ2xCLE1BQU1DLGdCQUFnQixNQUFNSCxNQUFNO1lBQ2xDLE1BQU1JLFlBQVksTUFBTUQsY0FBY0QsSUFBSTtZQUUxQyw2QkFBNkI7WUFDN0IsT0FBT1YsWUFBWWEsR0FBRyxDQUFDLENBQUNDO2dCQUN0QixNQUFNWixTQUFTLEdBQWlCLE9BQWRZLE9BQU9aLE1BQU0sRUFBQztnQkFDaEMsTUFBTWEsUUFBUU4sVUFBVU8sSUFBSSxDQUFDLENBQUNDLElBQVdBLEVBQUVmLE1BQU0sS0FBS0E7Z0JBQ3RELE1BQU1nQixRQUFRTixVQUFVSSxJQUFJLENBQUMsQ0FBQ0csSUFBV0EsRUFBRWpCLE1BQU0sS0FBS0E7Z0JBRXRELGlF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SUosVUFBVSxNQUFNO2dCQUNsQix1Q0FBdUM7Z0JBQ3ZDRyxRQUFRQSxRQUFTLEtBQUtMLENBQUFBLEtBQUtDLE1BQU0sS0FBSyxPQUFPLElBQUcsQ0FBQztZQUNuRCxPQUFPLElBQUlDLFVBQVUsUUFBUTtnQkFDM0IseUNBQXlDO2dCQUN6Q0csUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQsT0FBTztnQkFDTCxvQ0FBb0M7Z0JBQ3BDSSxRQUFRQSxRQUFTLEtBQUtMLENBQUFBLEtBQUtDLE1BQU0sS0FBSyxPQUFPLElBQUcsQ0FBQztZQUNuRDtZQUNBRyxPQUFPRyxJQUFJLENBQUNGO1FBQ2Q7UUFFQSxPQUFPRDtJQUNUOzthQW5OUXhCLFlBQThCO2FBQzlCRixVQUFvQmhELFlBQVlhLEdBQUcsQ0FBQyxDQUFDQyxTQUFXLEdBQStCLE9BQTVCQSxPQUFPWixNQUFNLENBQUNxQyxXQUFXLElBQUc7O0FBbU56RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFw5MTYyOVxcRG93bmxvYWRzXFxjcnlwdG8tZGFzaGJvYXJkXFxsaWJcXHNlcnZpY2VzXFxiaW5hbmNlLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDcnlwdG9EYXRhIH0gZnJvbSBcIkAvbGliL3R5cGVzXCJcblxuLy8gVG9wIGNyeXB0b2N1cnJlbmNpZXMgdG8gdHJhY2tcbmNvbnN0IFRPUF9DUllQVE9TID0gW1xuICB7IGlkOiBcImJpdGNvaW5cIiwgc3ltYm9sOiBcIkJUQ1wiLCBuYW1lOiBcIkJpdGNvaW5cIiwgaW1hZ2U6IFwiYnRjLnBuZ1wiIH0sXG4gIHsgaWQ6IFwiZXRoZXJldW1cIiwgc3ltYm9sOiBcIkVUSFwiLCBuYW1lOiBcIkV0aGVyZXVtXCIsIGltYWdlOiBcIi9jcnlwdG8taWNvbnMvZXRoLnBuZ1wiIH0sXG4gIHsgaWQ6IFwidGV0aGVyXCIsIHN5bWJvbDogXCJVU0RUXCIsIG5hbWU6IFwiVGV0aGVyXCIsIGltYWdlOiBcIi9jcnlwdG8taWNvbnMvdXNkdC5wbmdcIiB9LFxuICB7IGlkOiBcInJpcHBsZVwiLCBzeW1ib2w6IFwiWFJQXCIsIG5hbWU6IFwiWFJQXCIsIGltYWdlOiBcIi9jcnlwdG8taWNvbnMveHJwLnBuZ1wiIH0sXG4gIHsgaWQ6IFwiYmluYW5jZWNvaW5cIiwgc3ltYm9sOiBcIkJOQlwiLCBuYW1lOiBcIkJOQlwiLCBpbWFnZTogXCIvY3J5cHRvLWljb25zL2JuYi5wbmdcIiB9LFxuICB7IGlkOiBcInNvbGFuYVwiLCBzeW1ib2w6IFwiU09MXCIsIG5hbWU6IFwiU29sYW5hXCIsIGltYWdlOiBcIi9jcnlwdG8taWNvbnMvc29sLnBuZ1wiIH0sXG5dXG5cbmV4cG9ydCBjbGFzcyBCaW5hbmNlU2VydmljZSB7XG4gIHByaXZhdGUgd2Vic29ja2V0OiBXZWJTb2NrZXQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHN5bWJvbHM6IHN0cmluZ1tdID0gVE9QX0NSWVBUT1MubWFwKChjcnlwdG8pID0+IGAke2NyeXB0by5zeW1ib2wudG9Mb3dlckNhc2UoKX11c2R0YClcblxuICAvLyBGZXRjaCBpbml0aWFsIGNyeXB0byBkYXRhXG4gIGFzeW5jIGdldENyeXB0b0RhdGEoKTogUHJvbWlzZTxDcnlwdG9EYXRhW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggY3VycmVudCBwcmljZXNcbiAgICAgIGNvbnN0IHByaWNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92My90aWNrZXIvcHJpY2VcIilcbiAgICAgIGNvbnN0IHByaWNlRGF0YSA9IGF3YWl0IHByaWNlUmVzcG9uc2UuanNvbigpXG5cbiAgICAgIC8vIEZldGNoIDI0aCBzdGF0c1xuICAgICAgY29uc3Qgc3RhdHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzL3RpY2tlci8yNGhyXCIpXG4gICAgICBjb25zdCBzdGF0c0RhdGEgPSBhd2FpdCBzdGF0c1Jlc3BvbnNlLmpzb24oKVxuXG4gICAgICAvLyBNYXAgdGhlIGRhdGEgdG8gb3VyIGZvcm1hdFxuICAgICAgcmV0dXJuIFRPUF9DUllQVE9TLm1hcCgoY3J5cHRvKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGAke2NyeXB0by5zeW1ib2x9VVNEVGBcbiAgICAgICAgY29uc3QgcHJpY2UgPSBwcmljZURhdGEuZmluZCgocDogYW55KSA9PiBwLnN5bWJvbCA9PT0gc3ltYm9sKVxuICAgICAgICBjb25zdCBzdGF0cyA9IHN0YXRzRGF0YS5maW5kKChzOiBhbnkpID0+IHMuc3ltYm9sID09PSBzeW1ib2wpXG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIGRhdGEgZm9yIGZpZWxkcyBub3QgYXZhaWxhYmxlIGZyb20gQmluYW5jZSBBUElcbiAgICAgICAgY29uc3QgbWFya2V0Q2FwID0gdGhpcy5nZXRSYW5kb21NYXJrZXRDYXAoY3J5cHRvLnN5bWJvbClcbiAgICAgICAgY29uc3QgY2lyY3VsYXRpbmdTdXBwbHkgPSB0aGlzLmdldFJhbmRvbVN1cHBseShjcnlwdG8uc3ltYm9sKVxuICAgICAgICBjb25zdCBtYXhTdXBwbHkgPVxuICAgICAgICAgIGNyeXB0by5zeW1ib2wgPT09IFwiQlRDXCIgPyAyMTAwMDAwMCA6IGNyeXB0by5zeW1ib2wgPT09IFwiRVRIXCIgPyAwIDogdGhpcy5nZXRSYW5kb21NYXhTdXBwbHkoY3J5cHRvLnN5bWJvbClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBjcnlwdG8uaWQsXG4gICAgICAgICAgbmFtZTogY3J5cHRvLm5hbWUsXG4gICAgICAgICAgc3ltYm9sOiBjcnlwdG8uc3ltYm9sLFxuICAgICAgICAgIGltYWdlOiBjcnlwdG8uaW1hZ2UsXG4gICAgICAgICAgcHJpY2U6IE51bWJlci5wYXJzZUZsb2F0KHByaWNlPy5wcmljZSB8fCBcIjBcIiksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UxaDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDAuNSksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IHN0YXRzID8gTnVtYmVyLnBhcnNlRmxvYXQoc3RhdHMucHJpY2VDaGFuZ2VQZXJjZW50KSA6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgyKSxcbiAgICAgICAgICBwcmljZUNoYW5nZTdkOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoNSksXG4gICAgICAgICAgbWFya2V0Q2FwLFxuICAgICAgICAgIHZvbHVtZTI0aDogc3RhdHMgPyBOdW1iZXIucGFyc2VGbG9hdChzdGF0cy5xdW90ZVZvbHVtZSkgOiB0aGlzLmdldFJhbmRvbVZvbHVtZSgpLFxuICAgICAgICAgIHZvbHVtZTI0aEluQ3J5cHRvOiBzdGF0c1xuICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VGbG9hdChzdGF0cy52b2x1bWUpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0UmFuZG9tVm9sdW1lKCkgLyBOdW1iZXIucGFyc2VGbG9hdChwcmljZT8ucHJpY2UgfHwgXCIxXCIpLFxuICAgICAgICAgIGNpcmN1bGF0aW5nU3VwcGx5LFxuICAgICAgICAgIG1heFN1cHBseSxcbiAgICAgICAgICBzcGFya2xpbmU3ZDogYC9jcnlwdG8tY2hhcnRzLyR7Y3J5cHRvLnN5bWJvbC50b0xvd2VyQ2FzZSgpfS5zdmdgLFxuICAgICAgICAgIHNwYXJrbGluZURhdGE6IHRoaXMuZ2VuZXJhdGVTcGFya2xpbmVEYXRhKFxuICAgICAgICAgICAgY3J5cHRvLnN5bWJvbCxcbiAgICAgICAgICAgIGNyeXB0by5zeW1ib2wgPT09IFwiQlRDXCIgfHwgY3J5cHRvLnN5bWJvbCA9PT0gXCJFVEhcIiB8fCBjcnlwdG8uc3ltYm9sID09PSBcIlNPTFwiXG4gICAgICAgICAgICAgID8gXCJ1cFwiXG4gICAgICAgICAgICAgIDogY3J5cHRvLnN5bWJvbCA9PT0gXCJVU0RUXCJcbiAgICAgICAgICAgICAgICA/IFwidm9sYXRpbGVcIlxuICAgICAgICAgICAgICAgIDogXCJ1cFwiLFxuICAgICAgICAgICksXG4gICAgICAgICAgaXNGYXZvcml0ZTogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjcnlwdG8gZGF0YTpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXJ0IFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICBzdGFydFJlYWxUaW1lVXBkYXRlcyhjYWxsYmFjazogKHVwZGF0ZTogUGFydGlhbDxDcnlwdG9EYXRhPiAmIHsgaWQ6IHN0cmluZyB9KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgLy8gQ3JlYXRlIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gQmluYW5jZVxuICAgIGNvbnN0IHN0cmVhbXMgPSB0aGlzLnN5bWJvbHMubWFwKChzeW1ib2wpID0+IGAke3N5bWJvbH1AdGlja2VyYCkuam9pbihcIi9cIilcbiAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQoYHdzczovL3N0cmVhbS5iaW5hbmNlLmNvbTo5NDQzL3dzLyR7c3RyZWFtc31gKVxuXG4gICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuXG4gICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGNyeXB0b1xuICAgICAgY29uc3Qgc3ltYm9sID0gZGF0YS5zLnJlcGxhY2UoXCJVU0RUXCIsIFwiXCIpXG4gICAgICBjb25zdCBjcnlwdG8gPSBUT1BfQ1JZUFRPUy5maW5kKChjKSA9PiBjLnN5bWJvbCA9PT0gc3ltYm9sKVxuXG4gICAgICBpZiAoY3J5cHRvKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3J5cHRvIGRhdGFcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIGlkOiBjcnlwdG8uaWQsXG4gICAgICAgICAgcHJpY2U6IE51bWJlci5wYXJzZUZsb2F0KGRhdGEuYyksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IE51bWJlci5wYXJzZUZsb2F0KGRhdGEuUCksXG4gICAgICAgICAgcHJpY2VDaGFuZ2UxaDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDAuMyksIC8vIFNpbXVsYXRlIDFoIGNoYW5nZVxuICAgICAgICAgIHZvbHVtZTI0aDogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS5xKSxcbiAgICAgICAgICB2b2x1bWUyNGhJbkNyeXB0bzogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS52KSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IGVycm9yOlwiLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgV2ViU29ja2V0IGZhaWxzXG4gICAgICB0aGlzLnN0YXJ0UG9sbGluZyhjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0byBzdG9wIHRoZSBXZWJTb2NrZXRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud2Vic29ja2V0KSB7XG4gICAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKClcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiBXZWJTb2NrZXQgaXMgbm90IGF2YWlsYWJsZVxuICBwcml2YXRlIHN0YXJ0UG9sbGluZyhjYWxsYmFjazogKHVwZGF0ZTogUGFydGlhbDxDcnlwdG9EYXRhPiAmIHsgaWQ6IHN0cmluZyB9KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcmljZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjMvdGlja2VyL3ByaWNlXCIpXG4gICAgICAgIGNvbnN0IHByaWNlRGF0YSA9IGF3YWl0IHByaWNlUmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgVE9QX0NSWVBUT1MuZm9yRWFjaCgoY3J5cHRvKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gYCR7Y3J5cHRvLnN5bWJvbH1VU0RUYFxuICAgICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VEYXRhLmZpbmQoKHA6IGFueSkgPT4gcC5zeW1ib2wgPT09IHN5bWJvbClcblxuICAgICAgICAgIGlmIChwcmljZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICBpZDogY3J5cHRvLmlkLFxuICAgICAgICAgICAgICBwcmljZTogTnVtYmVyLnBhcnNlRmxvYXQocHJpY2UucHJpY2UpLFxuICAgICAgICAgICAgICBwcmljZUNoYW5nZTFoOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMC4zKSxcbiAgICAgICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgxKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBvbGxpbmcgY3J5cHRvIGRhdGE6XCIsIGVycm9yKVxuICAgICAgfVxuICAgIH0sIDIwMDApXG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzIHRvIGdlbmVyYXRlIHJhbmRvbSBkYXRhXG4gIHByaXZhdGUgZ2V0UmFuZG9tUGVyY2VudGFnZShtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBtYXggKiAyIC0gbWF4XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVZvbHVtZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDBcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmFuZG9tTWFya2V0Q2FwKHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBcIkJUQ1wiOlxuICAgICAgICByZXR1cm4gMTgwMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJFVEhcIjpcbiAgICAgICAgcmV0dXJuIDIxMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMFxuICAgICAgY2FzZSBcIlVTRFRcIjpcbiAgICAgICAgcmV0dXJuIDE0MDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA1MDAwMDAwMDAwXG4gICAgICBjYXNlIFwiWFJQXCI6XG4gICAgICAgIHJldHVybiAxMzAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogNTAwMDAwMDAwMFxuICAgICAgY2FzZSBcIkJOQlwiOlxuICAgICAgICByZXR1cm4gODUwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMjAwMDAwMDAwMFxuICAgICAgY2FzZSBcIlNPTFwiOlxuICAgICAgICByZXR1cm4gNzgwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMjAwMDAwMDAwMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDBcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVN1cHBseShzeW1ib2w6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgXCJCVENcIjpcbiAgICAgICAgcmV0dXJuIDE5ODUwMDAwXG4gICAgICBjYXNlIFwiRVRIXCI6XG4gICAgICAgIHJldHVybiAxMjA3MTAwMDBcbiAgICAgIGNhc2UgXCJVU0RUXCI6XG4gICAgICAgIHJldHVybiAxNDUyNzAwMDAwMDBcbiAgICAgIGNhc2UgXCJYUlBcIjpcbiAgICAgICAgcmV0dXJuIDU4MzkwMDAwMDAwXG4gICAgICBjYXNlIFwiQk5CXCI6XG4gICAgICAgIHJldHVybiAxNDA4OTAwMDBcbiAgICAgIGNhc2UgXCJTT0xcIjpcbiAgICAgICAgcmV0dXJuIDUxNzMxMDAwMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDBcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbU1heFN1cHBseShzeW1ib2w6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgXCJCVENcIjpcbiAgICAgICAgcmV0dXJuIDIxMDAwMDAwXG4gICAgICBjYXNlIFwiWFJQXCI6XG4gICAgICAgIHJldHVybiAxMDAwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJCTkJcIjpcbiAgICAgICAgcmV0dXJuIDIwMDAwMDAwMFxuICAgICAgY2FzZSBcIlNPTFwiOlxuICAgICAgICByZXR1cm4gNzAwMDAwMDAwXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVTcGFya2xpbmVEYXRhKHN5bWJvbDogc3RyaW5nLCB0cmVuZDogXCJ1cFwiIHwgXCJkb3duXCIgfCBcInZvbGF0aWxlXCIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbGVuZ3RoID0gMjRcbiAgICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW11cbiAgICBsZXQgdmFsdWUgPSAxMDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVuZCA9PT0gXCJ1cFwiKSB7XG4gICAgICAgIC8vIFVwd2FyZCB0cmVuZCB3aXRoIHNtYWxsIGZsdWN0dWF0aW9uc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDMgLSAwLjAxKSlcbiAgICAgIH0gZWxzZSBpZiAodHJlbmQgPT09IFwiZG93blwiKSB7XG4gICAgICAgIC8vIERvd253YXJkIHRyZW5kIHdpdGggc21hbGwgZmx1Y3R1YXRpb25zXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wMiAtIDAuMDMpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVm9sYXRpbGUgd2l0aCBsYXJnZXIgZmx1Y3R1YXRpb25zXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wOCAtIDAuMDQpKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG4iXSwibmFtZXMiOlsiVE9QX0NSWVBUT1MiLCJpZCIsInN5bWJvbCIsIm5hbWUiLCJpbWFnZSIsIkJpbmFuY2VTZXJ2aWNlIiwiZ2V0Q3J5cHRvRGF0YSIsInByaWNlUmVzcG9uc2UiLCJmZXRjaCIsInByaWNlRGF0YSIsImpzb24iLCJzdGF0c1Jlc3BvbnNlIiwic3RhdHNEYXRhIiwibWFwIiwiY3J5cHRvIiwicHJpY2UiLCJmaW5kIiwicCIsInN0YXRzIiwicyIsIm1hcmtldENhcCIsImdldFJhbmRvbU1hcmtldENhcCIsImNpcmN1bGF0aW5nU3VwcGx5IiwiZ2V0UmFuZG9tU3VwcGx5IiwibWF4U3VwcGx5IiwiZ2V0UmFuZG9tTWF4U3VwcGx5IiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsInByaWNlQ2hhbmdlMWgiLCJnZXRSYW5kb21QZXJjZW50YWdlIiwicHJpY2VDaGFuZ2UyNGgiLCJwcmljZUNoYW5nZVBlcmNlbnQiLCJwcmljZUNoYW5nZTdkIiwidm9sdW1lMjRoIiwicXVvdGVWb2x1bWUiLCJnZXRSYW5kb21Wb2x1bWUiLCJ2b2x1bWUyNGhJbkNyeXB0byIsInZvbHVtZSIsInNwYXJrbGluZTdkIiwidG9Mb3dlckNhc2UiLCJzcGFya2xpbmVEYXRhIiwiZ2VuZXJhdGVTcGFya2xpbmVEYXRhIiwiaXNGYXZvcml0ZSIsImVycm9yIiwiY29uc29sZSIsInN0YXJ0UmVhbFRpbWVVcGRhdGVzIiwiY2FsbGJhY2siLCJzdHJlYW1zIiwic3ltYm9scyIsImpvaW4iLCJ3ZWJzb2NrZXQiLCJXZWJTb2NrZXQiLCJvbm1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJyZXBsYWNlIiwiYyIsIlAiLCJxIiwidiIsIm9uZXJyb3IiLCJzdGFydFBvbGxpbmciLCJjbG9zZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJmb3JFYWNoIiwiY2xlYXJJbnRlcnZhbCIsIm1heCIsIk1hdGgiLCJyYW5kb20iLCJ0cmVuZCIsImxlbmd0aCIsInJlc3VsdCIsInZhbHVlIiwiaSIsInB1c2giXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/binance-service.ts\n"));

/***/ })

});
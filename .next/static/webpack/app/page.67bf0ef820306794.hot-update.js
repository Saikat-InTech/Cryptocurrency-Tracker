"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/binance-service.ts":
/*!*****************************************!*\
  !*** ./lib/services/binance-service.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinanceService: () => (/* binding */ BinanceService)\n/* harmony export */ });\n// Top cryptocurrencies to track\nconst TOP_CRYPTOS = [\n    {\n        id: \"bitcoin\",\n        symbol: \"BTC\",\n        name: \"Bitcoin\",\n        image: \"https://cryptologos.cc/logos/bitcoin-btc-logo.png?v=040\"\n    },\n    {\n        id: \"ethereum\",\n        symbol: \"ETH\",\n        name: \"Ethereum\",\n        image: \"/crypto-icons/eth.png\"\n    },\n    {\n        id: \"tether\",\n        symbol: \"USDT\",\n        name: \"Tether\",\n        image: \"/crypto-icons/usdt.png\"\n    },\n    {\n        id: \"ripple\",\n        symbol: \"XRP\",\n        name: \"XRP\",\n        image: \"/crypto-icons/xrp.png\"\n    },\n    {\n        id: \"binancecoin\",\n        symbol: \"BNB\",\n        name: \"BNB\",\n        image: \"/crypto-icons/bnb.png\"\n    },\n    {\n        id: \"solana\",\n        symbol: \"SOL\",\n        name: \"Solana\",\n        image: \"/crypto-icons/sol.png\"\n    }\n];\nclass BinanceService {\n    // Fetch initial crypto data\n    async getCryptoData() {\n        try {\n            // Fetch current prices\n            const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n            const priceData = await priceResponse.json();\n            // Fetch 24h stats\n            const statsResponse = await fetch(\"https://api.binance.com/api/v3/ticker/24hr\");\n            const statsData = await statsResponse.json();\n            // Map the data to our format\n            return TOP_CRYPTOS.map((crypto)=>{\n                const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                const price = priceData.find((p)=>p.symbol === symbol);\n                const stats = statsData.find((s)=>s.symbol === symbol);\n                // Generate random data for fields not available from Binance API\n                const marketCap = this.getRandomMarketCap(crypto.symbol);\n                const circulatingSupply = this.getRandomSupply(crypto.symbol);\n                const maxSupply = crypto.symbol === \"BTC\" ? 21000000 : crypto.symbol === \"ETH\" ? 0 : this.getRandomMaxSupply(crypto.symbol);\n                return {\n                    id: crypto.id,\n                    name: crypto.name,\n                    symbol: crypto.symbol,\n                    image: crypto.image,\n                    price: Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"0\"),\n                    priceChange1h: this.getRandomPercentage(0.5),\n                    priceChange24h: stats ? Number.parseFloat(stats.priceChangePercent) : this.getRandomPercentage(2),\n                    priceChange7d: this.getRandomPercentage(5),\n                    marketCap,\n                    volume24h: stats ? Number.parseFloat(stats.quoteVolume) : this.getRandomVolume(),\n                    volume24hInCrypto: stats ? Number.parseFloat(stats.volume) : this.getRandomVolume() / Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"1\"),\n                    circulatingSupply,\n                    maxSupply,\n                    sparkline7d: \"/crypto-charts/\".concat(crypto.symbol.toLowerCase(), \".svg\"),\n                    sparklineData: this.generateSparklineData(crypto.symbol, crypto.symbol === \"BTC\" || crypto.symbol === \"ETH\" || crypto.symbol === \"SOL\" ? \"up\" : crypto.symbol === \"USDT\" ? \"volatile\" : \"up\"),\n                    isFavorite: false\n                };\n            });\n        } catch (error) {\n            console.error(\"Error fetching crypto data:\", error);\n            throw error;\n        }\n    }\n    // Start WebSocket connection for real-time updates\n    startRealTimeUpdates(callback) {\n        // Create a WebSocket connection to Binance\n        const streams = this.symbols.map((symbol)=>\"\".concat(symbol, \"@ticker\")).join(\"/\");\n        this.websocket = new WebSocket(\"wss://stream.binance.com:9443/ws/\".concat(streams));\n        this.websocket.onmessage = (event)=>{\n            const data = JSON.parse(event.data);\n            // Find the corresponding crypto\n            const symbol = data.s.replace(\"USDT\", \"\");\n            const crypto = TOP_CRYPTOS.find((c)=>c.symbol === symbol);\n            if (crypto) {\n                // Update the crypto data\n                callback({\n                    id: crypto.id,\n                    price: Number.parseFloat(data.c),\n                    priceChange24h: Number.parseFloat(data.P),\n                    priceChange1h: this.getRandomPercentage(0.3),\n                    volume24h: Number.parseFloat(data.q),\n                    volume24hInCrypto: Number.parseFloat(data.v)\n                });\n            }\n        };\n        this.websocket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            // Fallback to polling if WebSocket fails\n            this.startPolling(callback);\n        };\n        // Return a function to stop the WebSocket\n        return ()=>{\n            if (this.websocket) {\n                this.websocket.close();\n                this.websocket = null;\n            }\n        };\n    }\n    // Fallback to polling if WebSocket is not available\n    startPolling(callback) {\n        const interval = setInterval(async ()=>{\n            try {\n                const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n                const priceData = await priceResponse.json();\n                TOP_CRYPTOS.forEach((crypto)=>{\n                    const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                    const price = priceData.find((p)=>p.symbol === symbol);\n                    if (price) {\n                        callback({\n                            id: crypto.id,\n                            price: Number.parseFloat(price.price),\n                            priceChange1h: this.getRandomPercentage(0.3),\n                            priceChange24h: this.getRandomPercentage(1)\n                        });\n                    }\n                });\n            } catch (error) {\n                console.error(\"Error polling crypto data:\", error);\n            }\n        }, 2000);\n        return ()=>clearInterval(interval);\n    }\n    // Helper methods to generate random data\n    getRandomPercentage(max) {\n        return Math.random() * max * 2 - max;\n    }\n    getRandomVolume() {\n        return Math.random() * 10000000000;\n    }\n    getRandomMarketCap(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 1800000000000 + Math.random() * 100000000000;\n            case \"ETH\":\n                return 210000000000 + Math.random() * 10000000000;\n            case \"USDT\":\n                return 140000000000 + Math.random() * 5000000000;\n            case \"XRP\":\n                return 130000000000 + Math.random() * 5000000000;\n            case \"BNB\":\n                return 85000000000 + Math.random() * 2000000000;\n            case \"SOL\":\n                return 78000000000 + Math.random() * 2000000000;\n            default:\n                return 10000000000 + Math.random() * 1000000000;\n        }\n    }\n    getRandomSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 19850000;\n            case \"ETH\":\n                return 120710000;\n            case \"USDT\":\n                return 145270000000;\n            case \"XRP\":\n                return 58390000000;\n            case \"BNB\":\n                return 140890000;\n            case \"SOL\":\n                return 517310000;\n            default:\n                return 1000000000;\n        }\n    }\n    getRandomMaxSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 21000000;\n            case \"XRP\":\n                return 100000000000;\n            case \"BNB\":\n                return 200000000;\n            case \"SOL\":\n                return 700000000;\n            default:\n                return 0;\n        }\n    }\n    generateSparklineData(symbol, trend) {\n        const length = 24;\n        const result = [];\n        let value = 100;\n        for(let i = 0; i < length; i++){\n            if (trend === \"up\") {\n                // Upward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.03 - 0.01));\n            } else if (trend === \"down\") {\n                // Downward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.02 - 0.03));\n            } else {\n                // Volatile with larger fluctuations\n                value = value * (1 + (Math.random() * 0.08 - 0.04));\n            }\n            result.push(value);\n        }\n        return result;\n    }\n    constructor(){\n        this.websocket = null;\n        this.symbols = TOP_CRYPTOS.map((crypto)=>\"\".concat(crypto.symbol.toLowerCase(), \"usdt\"));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9iaW5hbmNlLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBLGdDQUFnQztBQUNoQyxNQUFNQSxjQUFjO0lBQ2xCO1FBQUVDLElBQUk7UUFBV0MsUUFBUTtRQUFPQyxNQUFNO1FBQVdDLE9BQU87SUFBMEQ7SUFDbEg7UUFBRUgsSUFBSTtRQUFZQyxRQUFRO1FBQU9DLE1BQU07UUFBWUMsT0FBTztJQUF3QjtJQUNsRjtRQUFFSCxJQUFJO1FBQVVDLFFBQVE7UUFBUUMsTUFBTTtRQUFVQyxPQUFPO0lBQXlCO0lBQ2hGO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFPQyxNQUFNO1FBQU9DLE9BQU87SUFBd0I7SUFDM0U7UUFBRUgsSUFBSTtRQUFlQyxRQUFRO1FBQU9DLE1BQU07UUFBT0MsT0FBTztJQUF3QjtJQUNoRjtRQUFFSCxJQUFJO1FBQVVDLFFBQVE7UUFBT0MsTUFBTTtRQUFVQyxPQUFPO0lBQXdCO0NBQy9FO0FBRU0sTUFBTUM7SUFJWCw0QkFBNEI7SUFDNUIsTUFBTUMsZ0JBQXVDO1FBQzNDLElBQUk7WUFDRix1QkFBdUI7WUFDdkIsTUFBTUMsZ0JBQWdCLE1BQU1DLE1BQU07WUFDbEMsTUFBTUMsWUFBWSxNQUFNRixjQUFjRyxJQUFJO1lBRTFDLGtCQUFrQjtZQUNsQixNQUFNQyxnQkFBZ0IsTUFBTUgsTUFBTTtZQUNsQyxNQUFNSSxZQUFZLE1BQU1ELGNBQWNELElBQUk7WUFFMUMsNkJBQTZCO1lBQzdCLE9BQU9WLFlBQVlhLEdBQUcsQ0FBQyxDQUFDQztnQkFDdEIsTUFBTVosU0FBUyxHQUFpQixPQUFkWSxPQUFPWixNQUFNLEVBQUM7Z0JBQ2hDLE1BQU1hLFFBQVFOLFVBQVVPLElBQUksQ0FBQyxDQUFDQyxJQUFXQSxFQUFFZixNQUFNLEtBQUtBO2dCQUN0RCxNQUFNZ0IsUUFBUU4sVUFBVUksSUFBSSxDQUFDLENBQUNHLElBQVdBLEVBQUVqQixNQUFNLEtBQUtBO2dCQUV0RCxp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QUlKLFVBQVUsTUFBTTtnQkFDbEIsdUNBQXVDO2dCQUN2Q0csUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQsT0FBTyxJQUFJQyxVQUFVLFFBQVE7Z0JBQzNCLHlDQUF5QztnQkFDekNHLFFBQVFBLFFBQVMsS0FBS0wsQ0FBQUEsS0FBS0MsTUFBTSxLQUFLLE9BQU8sSUFBRyxDQUFDO1lBQ25ELE9BQU87Z0JBQ0wsb0NBQW9DO2dCQUNwQ0ksUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQ7WUFDQUcsT0FBT0csSUFBSSxDQUFDRjtRQUNkO1FBRUEsT0FBT0Q7SUFDVDs7YUFuTlF4QixZQUE4QjthQUM5QkYsVUFBb0JoRCxZQUFZYSxHQUFHLENBQUMsQ0FBQ0MsU0FBVyxHQUErQixPQUE1QkEsT0FBT1osTUFBTSxDQUFDcUMsV0FBVyxJQUFHOztBQW1OekYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcOTE2MjlcXERvd25sb2Fkc1xcY3J5cHRvLWRhc2hib2FyZFxcbGliXFxzZXJ2aWNlc1xcYmluYW5jZS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ3J5cHRvRGF0YSB9IGZyb20gXCJAL2xpYi90eXBlc1wiXG5cbi8vIFRvcCBjcnlwdG9jdXJyZW5jaWVzIHRvIHRyYWNrXG5jb25zdCBUT1BfQ1JZUFRPUyA9IFtcbiAgeyBpZDogXCJiaXRjb2luXCIsIHN5bWJvbDogXCJCVENcIiwgbmFtZTogXCJCaXRjb2luXCIsIGltYWdlOiBcImh0dHBzOi8vY3J5cHRvbG9nb3MuY2MvbG9nb3MvYml0Y29pbi1idGMtbG9nby5wbmc/dj0wNDBcIiB9LFxuICB7IGlkOiBcImV0aGVyZXVtXCIsIHN5bWJvbDogXCJFVEhcIiwgbmFtZTogXCJFdGhlcmV1bVwiLCBpbWFnZTogXCIvY3J5cHRvLWljb25zL2V0aC5wbmdcIiB9LFxuICB7IGlkOiBcInRldGhlclwiLCBzeW1ib2w6IFwiVVNEVFwiLCBuYW1lOiBcIlRldGhlclwiLCBpbWFnZTogXCIvY3J5cHRvLWljb25zL3VzZHQucG5nXCIgfSxcbiAgeyBpZDogXCJyaXBwbGVcIiwgc3ltYm9sOiBcIlhSUFwiLCBuYW1lOiBcIlhSUFwiLCBpbWFnZTogXCIvY3J5cHRvLWljb25zL3hycC5wbmdcIiB9LFxuICB7IGlkOiBcImJpbmFuY2Vjb2luXCIsIHN5bWJvbDogXCJCTkJcIiwgbmFtZTogXCJCTkJcIiwgaW1hZ2U6IFwiL2NyeXB0by1pY29ucy9ibmIucG5nXCIgfSxcbiAgeyBpZDogXCJzb2xhbmFcIiwgc3ltYm9sOiBcIlNPTFwiLCBuYW1lOiBcIlNvbGFuYVwiLCBpbWFnZTogXCIvY3J5cHRvLWljb25zL3NvbC5wbmdcIiB9LFxuXVxuXG5leHBvcnQgY2xhc3MgQmluYW5jZVNlcnZpY2Uge1xuICBwcml2YXRlIHdlYnNvY2tldDogV2ViU29ja2V0IHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBzeW1ib2xzOiBzdHJpbmdbXSA9IFRPUF9DUllQVE9TLm1hcCgoY3J5cHRvKSA9PiBgJHtjcnlwdG8uc3ltYm9sLnRvTG93ZXJDYXNlKCl9dXNkdGApXG5cbiAgLy8gRmV0Y2ggaW5pdGlhbCBjcnlwdG8gZGF0YVxuICBhc3luYyBnZXRDcnlwdG9EYXRhKCk6IFByb21pc2U8Q3J5cHRvRGF0YVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGN1cnJlbnQgcHJpY2VzXG4gICAgICBjb25zdCBwcmljZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjMvdGlja2VyL3ByaWNlXCIpXG4gICAgICBjb25zdCBwcmljZURhdGEgPSBhd2FpdCBwcmljZVJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAvLyBGZXRjaCAyNGggc3RhdHNcbiAgICAgIGNvbnN0IHN0YXRzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92My90aWNrZXIvMjRoclwiKVxuICAgICAgY29uc3Qgc3RhdHNEYXRhID0gYXdhaXQgc3RhdHNSZXNwb25zZS5qc29uKClcblxuICAgICAgLy8gTWFwIHRoZSBkYXRhIHRvIG91ciBmb3JtYXRcbiAgICAgIHJldHVybiBUT1BfQ1JZUFRPUy5tYXAoKGNyeXB0bykgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBgJHtjcnlwdG8uc3ltYm9sfVVTRFRgXG4gICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VEYXRhLmZpbmQoKHA6IGFueSkgPT4gcC5zeW1ib2wgPT09IHN5bWJvbClcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBzdGF0c0RhdGEuZmluZCgoczogYW55KSA9PiBzLnN5bWJvbCA9PT0gc3ltYm9sKVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBkYXRhIGZvciBmaWVsZHMgbm90IGF2YWlsYWJsZSBmcm9tIEJpbmFuY2UgQVBJXG4gICAgICAgIGNvbnN0IG1hcmtldENhcCA9IHRoaXMuZ2V0UmFuZG9tTWFya2V0Q2FwKGNyeXB0by5zeW1ib2wpXG4gICAgICAgIGNvbnN0IGNpcmN1bGF0aW5nU3VwcGx5ID0gdGhpcy5nZXRSYW5kb21TdXBwbHkoY3J5cHRvLnN5bWJvbClcbiAgICAgICAgY29uc3QgbWF4U3VwcGx5ID1cbiAgICAgICAgICBjcnlwdG8uc3ltYm9sID09PSBcIkJUQ1wiID8gMjEwMDAwMDAgOiBjcnlwdG8uc3ltYm9sID09PSBcIkVUSFwiID8gMCA6IHRoaXMuZ2V0UmFuZG9tTWF4U3VwcGx5KGNyeXB0by5zeW1ib2wpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogY3J5cHRvLmlkLFxuICAgICAgICAgIG5hbWU6IGNyeXB0by5uYW1lLFxuICAgICAgICAgIHN5bWJvbDogY3J5cHRvLnN5bWJvbCxcbiAgICAgICAgICBpbWFnZTogY3J5cHRvLmltYWdlLFxuICAgICAgICAgIHByaWNlOiBOdW1iZXIucGFyc2VGbG9hdChwcmljZT8ucHJpY2UgfHwgXCIwXCIpLFxuICAgICAgICAgIHByaWNlQ2hhbmdlMWg6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgwLjUpLFxuICAgICAgICAgIHByaWNlQ2hhbmdlMjRoOiBzdGF0cyA/IE51bWJlci5wYXJzZUZsb2F0KHN0YXRzLnByaWNlQ2hhbmdlUGVyY2VudCkgOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMiksXG4gICAgICAgICAgcHJpY2VDaGFuZ2U3ZDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDUpLFxuICAgICAgICAgIG1hcmtldENhcCxcbiAgICAgICAgICB2b2x1bWUyNGg6IHN0YXRzID8gTnVtYmVyLnBhcnNlRmxvYXQoc3RhdHMucXVvdGVWb2x1bWUpIDogdGhpcy5nZXRSYW5kb21Wb2x1bWUoKSxcbiAgICAgICAgICB2b2x1bWUyNGhJbkNyeXB0bzogc3RhdHNcbiAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlRmxvYXQoc3RhdHMudm9sdW1lKVxuICAgICAgICAgICAgOiB0aGlzLmdldFJhbmRvbVZvbHVtZSgpIC8gTnVtYmVyLnBhcnNlRmxvYXQocHJpY2U/LnByaWNlIHx8IFwiMVwiKSxcbiAgICAgICAgICBjaXJjdWxhdGluZ1N1cHBseSxcbiAgICAgICAgICBtYXhTdXBwbHksXG4gICAgICAgICAgc3BhcmtsaW5lN2Q6IGAvY3J5cHRvLWNoYXJ0cy8ke2NyeXB0by5zeW1ib2wudG9Mb3dlckNhc2UoKX0uc3ZnYCxcbiAgICAgICAgICBzcGFya2xpbmVEYXRhOiB0aGlzLmdlbmVyYXRlU3BhcmtsaW5lRGF0YShcbiAgICAgICAgICAgIGNyeXB0by5zeW1ib2wsXG4gICAgICAgICAgICBjcnlwdG8uc3ltYm9sID09PSBcIkJUQ1wiIHx8IGNyeXB0by5zeW1ib2wgPT09IFwiRVRIXCIgfHwgY3J5cHRvLnN5bWJvbCA9PT0gXCJTT0xcIlxuICAgICAgICAgICAgICA/IFwidXBcIlxuICAgICAgICAgICAgICA6IGNyeXB0by5zeW1ib2wgPT09IFwiVVNEVFwiXG4gICAgICAgICAgICAgICAgPyBcInZvbGF0aWxlXCJcbiAgICAgICAgICAgICAgICA6IFwidXBcIixcbiAgICAgICAgICApLFxuICAgICAgICAgIGlzRmF2b3JpdGU6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgY3J5cHRvIGRhdGE6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBTdGFydCBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcbiAgc3RhcnRSZWFsVGltZVVwZGF0ZXMoY2FsbGJhY2s6ICh1cGRhdGU6IFBhcnRpYWw8Q3J5cHRvRGF0YT4gJiB7IGlkOiBzdHJpbmcgfSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIC8vIENyZWF0ZSBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIEJpbmFuY2VcbiAgICBjb25zdCBzdHJlYW1zID0gdGhpcy5zeW1ib2xzLm1hcCgoc3ltYm9sKSA9PiBgJHtzeW1ib2x9QHRpY2tlcmApLmpvaW4oXCIvXCIpXG4gICAgdGhpcy53ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KGB3c3M6Ly9zdHJlYW0uYmluYW5jZS5jb206OTQ0My93cy8ke3N0cmVhbXN9YClcblxuICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcblxuICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBjcnlwdG9cbiAgICAgIGNvbnN0IHN5bWJvbCA9IGRhdGEucy5yZXBsYWNlKFwiVVNEVFwiLCBcIlwiKVxuICAgICAgY29uc3QgY3J5cHRvID0gVE9QX0NSWVBUT1MuZmluZCgoYykgPT4gYy5zeW1ib2wgPT09IHN5bWJvbClcblxuICAgICAgaWYgKGNyeXB0bykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGNyeXB0byBkYXRhXG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBpZDogY3J5cHRvLmlkLFxuICAgICAgICAgIHByaWNlOiBOdW1iZXIucGFyc2VGbG9hdChkYXRhLmMpLFxuICAgICAgICAgIHByaWNlQ2hhbmdlMjRoOiBOdW1iZXIucGFyc2VGbG9hdChkYXRhLlApLFxuICAgICAgICAgIHByaWNlQ2hhbmdlMWg6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgwLjMpLCAvLyBTaW11bGF0ZSAxaCBjaGFuZ2VcbiAgICAgICAgICB2b2x1bWUyNGg6IE51bWJlci5wYXJzZUZsb2F0KGRhdGEucSksXG4gICAgICAgICAgdm9sdW1lMjRoSW5DcnlwdG86IE51bWJlci5wYXJzZUZsb2F0KGRhdGEudiksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIldlYlNvY2tldCBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICAvLyBGYWxsYmFjayB0byBwb2xsaW5nIGlmIFdlYlNvY2tldCBmYWlsc1xuICAgICAgdGhpcy5zdGFydFBvbGxpbmcoY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdG8gc3RvcCB0aGUgV2ViU29ja2V0XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aGlzLndlYnNvY2tldCkge1xuICAgICAgICB0aGlzLndlYnNvY2tldC5jbG9zZSgpXG4gICAgICAgIHRoaXMud2Vic29ja2V0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgV2ViU29ja2V0IGlzIG5vdCBhdmFpbGFibGVcbiAgcHJpdmF0ZSBzdGFydFBvbGxpbmcoY2FsbGJhY2s6ICh1cGRhdGU6IFBhcnRpYWw8Q3J5cHRvRGF0YT4gJiB7IGlkOiBzdHJpbmcgfSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJpY2VSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzL3RpY2tlci9wcmljZVwiKVxuICAgICAgICBjb25zdCBwcmljZURhdGEgPSBhd2FpdCBwcmljZVJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIFRPUF9DUllQVE9TLmZvckVhY2goKGNyeXB0bykgPT4ge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGAke2NyeXB0by5zeW1ib2x9VVNEVGBcbiAgICAgICAgICBjb25zdCBwcmljZSA9IHByaWNlRGF0YS5maW5kKChwOiBhbnkpID0+IHAuc3ltYm9sID09PSBzeW1ib2wpXG5cbiAgICAgICAgICBpZiAocHJpY2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgaWQ6IGNyeXB0by5pZCxcbiAgICAgICAgICAgICAgcHJpY2U6IE51bWJlci5wYXJzZUZsb2F0KHByaWNlLnByaWNlKSxcbiAgICAgICAgICAgICAgcHJpY2VDaGFuZ2UxaDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDAuMyksXG4gICAgICAgICAgICAgIHByaWNlQ2hhbmdlMjRoOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwb2xsaW5nIGNyeXB0byBkYXRhOlwiLCBlcnJvcilcbiAgICAgIH1cbiAgICB9LCAyMDAwKVxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kcyB0byBnZW5lcmF0ZSByYW5kb20gZGF0YVxuICBwcml2YXRlIGdldFJhbmRvbVBlcmNlbnRhZ2UobWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogbWF4ICogMiAtIG1heFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21Wb2x1bWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwXG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbU1hcmtldENhcChzeW1ib2w6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgIGNhc2UgXCJCVENcIjpcbiAgICAgICAgcmV0dXJuIDE4MDAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDAwXG4gICAgICBjYXNlIFwiRVRIXCI6XG4gICAgICAgIHJldHVybiAyMTAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJVU0RUXCI6XG4gICAgICAgIHJldHVybiAxNDAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogNTAwMDAwMDAwMFxuICAgICAgY2FzZSBcIlhSUFwiOlxuICAgICAgICByZXR1cm4gMTMwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDUwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJCTkJcIjpcbiAgICAgICAgcmV0dXJuIDg1MDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDIwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJTT0xcIjpcbiAgICAgICAgcmV0dXJuIDc4MDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDIwMDAwMDAwMDBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAxMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21TdXBwbHkoc3ltYm9sOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICBjYXNlIFwiQlRDXCI6XG4gICAgICAgIHJldHVybiAxOTg1MDAwMFxuICAgICAgY2FzZSBcIkVUSFwiOlxuICAgICAgICByZXR1cm4gMTIwNzEwMDAwXG4gICAgICBjYXNlIFwiVVNEVFwiOlxuICAgICAgICByZXR1cm4gMTQ1MjcwMDAwMDAwXG4gICAgICBjYXNlIFwiWFJQXCI6XG4gICAgICAgIHJldHVybiA1ODM5MDAwMDAwMFxuICAgICAgY2FzZSBcIkJOQlwiOlxuICAgICAgICByZXR1cm4gMTQwODkwMDAwXG4gICAgICBjYXNlIFwiU09MXCI6XG4gICAgICAgIHJldHVybiA1MTczMTAwMDBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAxMDAwMDAwMDAwXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21NYXhTdXBwbHkoc3ltYm9sOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICBjYXNlIFwiQlRDXCI6XG4gICAgICAgIHJldHVybiAyMTAwMDAwMFxuICAgICAgY2FzZSBcIlhSUFwiOlxuICAgICAgICByZXR1cm4gMTAwMDAwMDAwMDAwXG4gICAgICBjYXNlIFwiQk5CXCI6XG4gICAgICAgIHJldHVybiAyMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJTT0xcIjpcbiAgICAgICAgcmV0dXJuIDcwMDAwMDAwMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlU3BhcmtsaW5lRGF0YShzeW1ib2w6IHN0cmluZywgdHJlbmQ6IFwidXBcIiB8IFwiZG93blwiIHwgXCJ2b2xhdGlsZVwiKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGxlbmd0aCA9IDI0XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdXG4gICAgbGV0IHZhbHVlID0gMTAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlbmQgPT09IFwidXBcIikge1xuICAgICAgICAvLyBVcHdhcmQgdHJlbmQgd2l0aCBzbWFsbCBmbHVjdHVhdGlvbnNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqICgxICsgKE1hdGgucmFuZG9tKCkgKiAwLjAzIC0gMC4wMSkpXG4gICAgICB9IGVsc2UgaWYgKHRyZW5kID09PSBcImRvd25cIikge1xuICAgICAgICAvLyBEb3dud2FyZCB0cmVuZCB3aXRoIHNtYWxsIGZsdWN0dWF0aW9uc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDIgLSAwLjAzKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZvbGF0aWxlIHdpdGggbGFyZ2VyIGZsdWN0dWF0aW9uc1xuICAgICAgICB2YWx1ZSA9IHZhbHVlICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMDggLSAwLjA0KSlcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRPUF9DUllQVE9TIiwiaWQiLCJzeW1ib2wiLCJuYW1lIiwiaW1hZ2UiLCJCaW5hbmNlU2VydmljZSIsImdldENyeXB0b0RhdGEiLCJwcmljZVJlc3BvbnNlIiwiZmV0Y2giLCJwcmljZURhdGEiLCJqc29uIiwic3RhdHNSZXNwb25zZSIsInN0YXRzRGF0YSIsIm1hcCIsImNyeXB0byIsInByaWNlIiwiZmluZCIsInAiLCJzdGF0cyIsInMiLCJtYXJrZXRDYXAiLCJnZXRSYW5kb21NYXJrZXRDYXAiLCJjaXJjdWxhdGluZ1N1cHBseSIsImdldFJhbmRvbVN1cHBseSIsIm1heFN1cHBseSIsImdldFJhbmRvbU1heFN1cHBseSIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJwcmljZUNoYW5nZTFoIiwiZ2V0UmFuZG9tUGVyY2VudGFnZSIsInByaWNlQ2hhbmdlMjRoIiwicHJpY2VDaGFuZ2VQZXJjZW50IiwicHJpY2VDaGFuZ2U3ZCIsInZvbHVtZTI0aCIsInF1b3RlVm9sdW1lIiwiZ2V0UmFuZG9tVm9sdW1lIiwidm9sdW1lMjRoSW5DcnlwdG8iLCJ2b2x1bWUiLCJzcGFya2xpbmU3ZCIsInRvTG93ZXJDYXNlIiwic3BhcmtsaW5lRGF0YSIsImdlbmVyYXRlU3BhcmtsaW5lRGF0YSIsImlzRmF2b3JpdGUiLCJlcnJvciIsImNvbnNvbGUiLCJzdGFydFJlYWxUaW1lVXBkYXRlcyIsImNhbGxiYWNrIiwic3RyZWFtcyIsInN5bWJvbHMiLCJqb2luIiwid2Vic29ja2V0IiwiV2ViU29ja2V0Iiwib25tZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVwbGFjZSIsImMiLCJQIiwicSIsInYiLCJvbmVycm9yIiwic3RhcnRQb2xsaW5nIiwiY2xvc2UiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiZm9yRWFjaCIsImNsZWFySW50ZXJ2YWwiLCJtYXgiLCJNYXRoIiwicmFuZG9tIiwidHJlbmQiLCJsZW5ndGgiLCJyZXN1bHQiLCJ2YWx1ZSIsImkiLCJwdXNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/binance-service.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/binance-service.ts":
/*!*****************************************!*\
  !*** ./lib/services/binance-service.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinanceService: () => (/* binding */ BinanceService)\n/* harmony export */ });\n// Top cryptocurrencies to track\nconst TOP_CRYPTOS = [\n    {\n        id: \"bitcoin\",\n        symbol: \"BTC\",\n        name: \"Bitcoin\",\n        image: \"btc\"\n    },\n    {\n        id: \"ethereum\",\n        symbol: \"ETH\",\n        name: \"Ethereum\",\n        image: \"/crypto-icons/eth.png\"\n    },\n    {\n        id: \"tether\",\n        symbol: \"USDT\",\n        name: \"Tether\",\n        image: \"/crypto-icons/usdt.png\"\n    },\n    {\n        id: \"ripple\",\n        symbol: \"XRP\",\n        name: \"XRP\",\n        image: \"/crypto-icons/xrp.png\"\n    },\n    {\n        id: \"binancecoin\",\n        symbol: \"BNB\",\n        name: \"BNB\",\n        image: \"/crypto-icons/bnb.png\"\n    },\n    {\n        id: \"solana\",\n        symbol: \"SOL\",\n        name: \"Solana\",\n        image: \"/crypto-icons/sol.png\"\n    }\n];\nclass BinanceService {\n    // Fetch initial crypto data\n    async getCryptoData() {\n        try {\n            // Fetch current prices\n            const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n            const priceData = await priceResponse.json();\n            // Fetch 24h stats\n            const statsResponse = await fetch(\"https://api.binance.com/api/v3/ticker/24hr\");\n            const statsData = await statsResponse.json();\n            // Map the data to our format\n            return TOP_CRYPTOS.map((crypto)=>{\n                const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                const price = priceData.find((p)=>p.symbol === symbol);\n                const stats = statsData.find((s)=>s.symbol === symbol);\n                // Generate random data for fields not available from Binance API\n                const marketCap = this.getRandomMarketCap(crypto.symbol);\n                const circulatingSupply = this.getRandomSupply(crypto.symbol);\n                const maxSupply = crypto.symbol === \"BTC\" ? 21000000 : crypto.symbol === \"ETH\" ? 0 : this.getRandomMaxSupply(crypto.symbol);\n                return {\n                    id: crypto.id,\n                    name: crypto.name,\n                    symbol: crypto.symbol,\n                    image: crypto.image,\n                    price: Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"0\"),\n                    priceChange1h: this.getRandomPercentage(0.5),\n                    priceChange24h: stats ? Number.parseFloat(stats.priceChangePercent) : this.getRandomPercentage(2),\n                    priceChange7d: this.getRandomPercentage(5),\n                    marketCap,\n                    volume24h: stats ? Number.parseFloat(stats.quoteVolume) : this.getRandomVolume(),\n                    volume24hInCrypto: stats ? Number.parseFloat(stats.volume) : this.getRandomVolume() / Number.parseFloat((price === null || price === void 0 ? void 0 : price.price) || \"1\"),\n                    circulatingSupply,\n                    maxSupply,\n                    sparkline7d: \"/crypto-charts/\".concat(crypto.symbol.toLowerCase(), \".svg\"),\n                    sparklineData: this.generateSparklineData(crypto.symbol, crypto.symbol === \"BTC\" || crypto.symbol === \"ETH\" || crypto.symbol === \"SOL\" ? \"up\" : crypto.symbol === \"USDT\" ? \"volatile\" : \"up\"),\n                    isFavorite: false\n                };\n            });\n        } catch (error) {\n            console.error(\"Error fetching crypto data:\", error);\n            throw error;\n        }\n    }\n    // Start WebSocket connection for real-time updates\n    startRealTimeUpdates(callback) {\n        // Create a WebSocket connection to Binance\n        const streams = this.symbols.map((symbol)=>\"\".concat(symbol, \"@ticker\")).join(\"/\");\n        this.websocket = new WebSocket(\"wss://stream.binance.com:9443/ws/\".concat(streams));\n        this.websocket.onmessage = (event)=>{\n            const data = JSON.parse(event.data);\n            // Find the corresponding crypto\n            const symbol = data.s.replace(\"USDT\", \"\");\n            const crypto = TOP_CRYPTOS.find((c)=>c.symbol === symbol);\n            if (crypto) {\n                // Update the crypto data\n                callback({\n                    id: crypto.id,\n                    price: Number.parseFloat(data.c),\n                    priceChange24h: Number.parseFloat(data.P),\n                    priceChange1h: this.getRandomPercentage(0.3),\n                    volume24h: Number.parseFloat(data.q),\n                    volume24hInCrypto: Number.parseFloat(data.v)\n                });\n            }\n        };\n        this.websocket.onerror = (error)=>{\n            console.error(\"WebSocket error:\", error);\n            // Fallback to polling if WebSocket fails\n            this.startPolling(callback);\n        };\n        // Return a function to stop the WebSocket\n        return ()=>{\n            if (this.websocket) {\n                this.websocket.close();\n                this.websocket = null;\n            }\n        };\n    }\n    // Fallback to polling if WebSocket is not available\n    startPolling(callback) {\n        const interval = setInterval(async ()=>{\n            try {\n                const priceResponse = await fetch(\"https://api.binance.com/api/v3/ticker/price\");\n                const priceData = await priceResponse.json();\n                TOP_CRYPTOS.forEach((crypto)=>{\n                    const symbol = \"\".concat(crypto.symbol, \"USDT\");\n                    const price = priceData.find((p)=>p.symbol === symbol);\n                    if (price) {\n                        callback({\n                            id: crypto.id,\n                            price: Number.parseFloat(price.price),\n                            priceChange1h: this.getRandomPercentage(0.3),\n                            priceChange24h: this.getRandomPercentage(1)\n                        });\n                    }\n                });\n            } catch (error) {\n                console.error(\"Error polling crypto data:\", error);\n            }\n        }, 2000);\n        return ()=>clearInterval(interval);\n    }\n    // Helper methods to generate random data\n    getRandomPercentage(max) {\n        return Math.random() * max * 2 - max;\n    }\n    getRandomVolume() {\n        return Math.random() * 10000000000;\n    }\n    getRandomMarketCap(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 1800000000000 + Math.random() * 100000000000;\n            case \"ETH\":\n                return 210000000000 + Math.random() * 10000000000;\n            case \"USDT\":\n                return 140000000000 + Math.random() * 5000000000;\n            case \"XRP\":\n                return 130000000000 + Math.random() * 5000000000;\n            case \"BNB\":\n                return 85000000000 + Math.random() * 2000000000;\n            case \"SOL\":\n                return 78000000000 + Math.random() * 2000000000;\n            default:\n                return 10000000000 + Math.random() * 1000000000;\n        }\n    }\n    getRandomSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 19850000;\n            case \"ETH\":\n                return 120710000;\n            case \"USDT\":\n                return 145270000000;\n            case \"XRP\":\n                return 58390000000;\n            case \"BNB\":\n                return 140890000;\n            case \"SOL\":\n                return 517310000;\n            default:\n                return 1000000000;\n        }\n    }\n    getRandomMaxSupply(symbol) {\n        switch(symbol){\n            case \"BTC\":\n                return 21000000;\n            case \"XRP\":\n                return 100000000000;\n            case \"BNB\":\n                return 200000000;\n            case \"SOL\":\n                return 700000000;\n            default:\n                return 0;\n        }\n    }\n    generateSparklineData(symbol, trend) {\n        const length = 24;\n        const result = [];\n        let value = 100;\n        for(let i = 0; i < length; i++){\n            if (trend === \"up\") {\n                // Upward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.03 - 0.01));\n            } else if (trend === \"down\") {\n                // Downward trend with small fluctuations\n                value = value * (1 + (Math.random() * 0.02 - 0.03));\n            } else {\n                // Volatile with larger fluctuations\n                value = value * (1 + (Math.random() * 0.08 - 0.04));\n            }\n            result.push(value);\n        }\n        return result;\n    }\n    constructor(){\n        this.websocket = null;\n        this.symbols = TOP_CRYPTOS.map((crypto)=>\"\".concat(crypto.symbol.toLowerCase(), \"usdt\"));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9iaW5hbmNlLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUVBLGdDQUFnQztBQUNoQyxNQUFNQSxjQUFjO0lBQ2xCO1FBQUVDLElBQUk7UUFBV0MsUUFBUTtRQUFPQyxNQUFNO1FBQVdDLE9BQU87SUFBTTtJQUM5RDtRQUFFSCxJQUFJO1FBQVlDLFFBQVE7UUFBT0MsTUFBTTtRQUFZQyxPQUFPO0lBQXdCO0lBQ2xGO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFRQyxNQUFNO1FBQVVDLE9BQU87SUFBeUI7SUFDaEY7UUFBRUgsSUFBSTtRQUFVQyxRQUFRO1FBQU9DLE1BQU07UUFBT0MsT0FBTztJQUF3QjtJQUMzRTtRQUFFSCxJQUFJO1FBQWVDLFFBQVE7UUFBT0MsTUFBTTtRQUFPQyxPQUFPO0lBQXdCO0lBQ2hGO1FBQUVILElBQUk7UUFBVUMsUUFBUTtRQUFPQyxNQUFNO1FBQVVDLE9BQU87SUFBd0I7Q0FDL0U7QUFFTSxNQUFNQztJQUlYLDRCQUE0QjtJQUM1QixNQUFNQyxnQkFBdUM7UUFDM0MsSUFBSTtZQUNGLHVCQUF1QjtZQUN2QixNQUFNQyxnQkFBZ0IsTUFBTUMsTUFBTTtZQUNsQyxNQUFNQyxZQUFZLE1BQU1GLGNBQWNHLElBQUk7WUFFMUMsa0JBQWtCO1lBQ2xCLE1BQU1DLGdCQUFnQixNQUFNSCxNQUFNO1lBQ2xDLE1BQU1JLFlBQVksTUFBTUQsY0FBY0QsSUFBSTtZQUUxQyw2QkFBNkI7WUFDN0IsT0FBT1YsWUFBWWEsR0FBRyxDQUFDLENBQUNDO2dCQUN0QixNQUFNWixTQUFTLEdBQWlCLE9BQWRZLE9BQU9aLE1BQU0sRUFBQztnQkFDaEMsTUFBTWEsUUFBUU4sVUFBVU8sSUFBSSxDQUFDLENBQUNDLElBQVdBLEVBQUVmLE1BQU0sS0FBS0E7Z0JBQ3RELE1BQU1nQixRQUFRTixVQUFVSSxJQUFJLENBQUMsQ0FBQ0csSUFBV0EsRUFBRWpCLE1BQU0sS0FBS0E7Z0JBRXRELGlFQUFpRTtnQkFDakUsTUFBTWtCLFlBQVksSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ1AsT0FBT1osTUFBTTtnQkFDdkQsTUFBTW9CLG9CQUFvQixJQUFJLENBQUNDLGVBQWUsQ0FBQ1QsT0FBT1osTUFBTTtnQkFDNUQsTUFBTXNCLFlBQ0pWLE9BQU9aLE1BQU0sS0FBSyxRQUFRLFdBQVdZLE9BQU9aLE1BQU0sS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDdUIsa0JBQWtCLENBQUNYLE9BQU9aLE1BQU07Z0JBRTFHLE9BQU87b0JBQ0xELElBQUlhLE9BQU9iLEVBQUU7b0JBQ2JFLE1BQU1XLE9BQU9YLElBQUk7b0JBQ2pCRCxRQUFRWSxPQUFPWixNQUFNO29CQUNyQkUsT0FBT1UsT0FBT1YsS0FBSztvQkFDbkJXLE9BQU9XLE9BQU9DLFVBQVUsQ0FBQ1osQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPQSxLQUFLLEtBQUk7b0JBQ3pDYSxlQUFlLElBQUksQ0FBQ0MsbUJBQW1CLENBQUM7b0JBQ3hDQyxnQkFBZ0JaLFFBQVFRLE9BQU9DLFVBQVUsQ0FBQ1QsTUFBTWEsa0JBQWtCLElBQUksSUFBSSxDQUFDRixtQkFBbUIsQ0FBQztvQkFDL0ZHLGVBQWUsSUFBSSxDQUFDSCxtQkFBbUIsQ0FBQztvQkFDeENUO29CQUNBYSxXQUFXZixRQUFRUSxPQUFPQyxVQUFVLENBQUNULE1BQU1nQixXQUFXLElBQUksSUFBSSxDQUFDQyxlQUFlO29CQUM5RUMsbUJBQW1CbEIsUUFDZlEsT0FBT0MsVUFBVSxDQUFDVCxNQUFNbUIsTUFBTSxJQUM5QixJQUFJLENBQUNGLGVBQWUsS0FBS1QsT0FBT0MsVUFBVSxDQUFDWixDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU9BLEtBQUssS0FBSTtvQkFDL0RPO29CQUNBRTtvQkFDQWMsYUFBYSxrQkFBOEMsT0FBNUJ4QixPQUFPWixNQUFNLENBQUNxQyxXQUFXLElBQUc7b0JBQzNEQyxlQUFlLElBQUksQ0FBQ0MscUJBQXFCLENBQ3ZDM0IsT0FBT1osTUFBTSxFQUNiWSxPQUFPWixNQUFNLEtBQUssU0FBU1ksT0FBT1osTUFBTSxLQUFLLFNBQVNZLE9BQU9aLE1BQU0sS0FBSyxRQUNwRSxPQUNBWSxPQUFPWixNQUFNLEtBQUssU0FDaEIsYUFDQTtvQkFFUndDLFlBQVk7Z0JBQ2Q7WUFDRjtRQUNGLEVBQUUsT0FBT0MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxtREFBbUQ7SUFDbkRFLHFCQUFxQkMsUUFBZ0UsRUFBYztRQUNqRywyQ0FBMkM7UUFDM0MsTUFBTUMsVUFBVSxJQUFJLENBQUNDLE9BQU8sQ0FBQ25DLEdBQUcsQ0FBQyxDQUFDWCxTQUFXLEdBQVUsT0FBUEEsUUFBTyxZQUFVK0MsSUFBSSxDQUFDO1FBQ3RFLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUlDLFVBQVUsb0NBQTRDLE9BQVJKO1FBRW5FLElBQUksQ0FBQ0csU0FBUyxDQUFDRSxTQUFTLEdBQUcsQ0FBQ0M7WUFDMUIsTUFBTUMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSCxNQUFNQyxJQUFJO1lBRWxDLGdDQUFnQztZQUNoQyxNQUFNcEQsU0FBU29ELEtBQUtuQyxDQUFDLENBQUNzQyxPQUFPLENBQUMsUUFBUTtZQUN0QyxNQUFNM0MsU0FBU2QsWUFBWWdCLElBQUksQ0FBQyxDQUFDMEMsSUFBTUEsRUFBRXhELE1BQU0sS0FBS0E7WUFFcEQsSUFBSVksUUFBUTtnQkFDVix5QkFBeUI7Z0JBQ3pCZ0MsU0FBUztvQkFDUDdDLElBQUlhLE9BQU9iLEVBQUU7b0JBQ2JjLE9BQU9XLE9BQU9DLFVBQVUsQ0FBQzJCLEtBQUtJLENBQUM7b0JBQy9CNUIsZ0JBQWdCSixPQUFPQyxVQUFVLENBQUMyQixLQUFLSyxDQUFDO29CQUN4Qy9CLGVBQWUsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQztvQkFDeENJLFdBQVdQLE9BQU9DLFVBQVUsQ0FBQzJCLEtBQUtNLENBQUM7b0JBQ25DeEIsbUJBQW1CVixPQUFPQyxVQUFVLENBQUMyQixLQUFLTyxDQUFDO2dCQUM3QztZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNYLFNBQVMsQ0FBQ1ksT0FBTyxHQUFHLENBQUNuQjtZQUN4QkMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkE7WUFDbEMseUNBQXlDO1lBQ3pDLElBQUksQ0FBQ29CLFlBQVksQ0FBQ2pCO1FBQ3BCO1FBRUEsMENBQTBDO1FBQzFDLE9BQU87WUFDTCxJQUFJLElBQUksQ0FBQ0ksU0FBUyxFQUFFO2dCQUNsQixJQUFJLENBQUNBLFNBQVMsQ0FBQ2MsS0FBSztnQkFDcEIsSUFBSSxDQUFDZCxTQUFTLEdBQUc7WUFDbkI7UUFDRjtJQUNGO0lBRUEsb0RBQW9EO0lBQzVDYSxhQUFhakIsUUFBZ0UsRUFBYztRQUNqRyxNQUFNbUIsV0FBV0MsWUFBWTtZQUMzQixJQUFJO2dCQUNGLE1BQU0zRCxnQkFBZ0IsTUFBTUMsTUFBTTtnQkFDbEMsTUFBTUMsWUFBWSxNQUFNRixjQUFjRyxJQUFJO2dCQUUxQ1YsWUFBWW1FLE9BQU8sQ0FBQyxDQUFDckQ7b0JBQ25CLE1BQU1aLFNBQVMsR0FBaUIsT0FBZFksT0FBT1osTUFBTSxFQUFDO29CQUNoQyxNQUFNYSxRQUFRTixVQUFVTyxJQUFJLENBQUMsQ0FBQ0MsSUFBV0EsRUFBRWYsTUFBTSxLQUFLQTtvQkFFdEQsSUFBSWEsT0FBTzt3QkFDVCtCLFNBQVM7NEJBQ1A3QyxJQUFJYSxPQUFPYixFQUFFOzRCQUNiYyxPQUFPVyxPQUFPQyxVQUFVLENBQUNaLE1BQU1BLEtBQUs7NEJBQ3BDYSxlQUFlLElBQUksQ0FBQ0MsbUJBQW1CLENBQUM7NEJBQ3hDQyxnQkFBZ0IsSUFBSSxDQUFDRCxtQkFBbUIsQ0FBQzt3QkFDM0M7b0JBQ0Y7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9jLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1lBQzlDO1FBQ0YsR0FBRztRQUVILE9BQU8sSUFBTXlCLGNBQWNIO0lBQzdCO0lBRUEseUNBQXlDO0lBQ2pDcEMsb0JBQW9Cd0MsR0FBVyxFQUFVO1FBQy9DLE9BQU9DLEtBQUtDLE1BQU0sS0FBS0YsTUFBTSxJQUFJQTtJQUNuQztJQUVRbEMsa0JBQTBCO1FBQ2hDLE9BQU9tQyxLQUFLQyxNQUFNLEtBQUs7SUFDekI7SUFFUWxELG1CQUFtQm5CLE1BQWMsRUFBVTtRQUNqRCxPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTyxnQkFBZ0JvRSxLQUFLQyxNQUFNLEtBQUs7WUFDekMsS0FBSztnQkFDSCxPQUFPLGVBQWVELEtBQUtDLE1BQU0sS0FBSztZQUN4QyxLQUFLO2dCQUNILE9BQU8sZUFBZUQsS0FBS0MsTUFBTSxLQUFLO1lBQ3hDLEtBQUs7Z0JBQ0gsT0FBTyxlQUFlRCxLQUFLQyxNQUFNLEtBQUs7WUFDeEMsS0FBSztnQkFDSCxPQUFPLGNBQWNELEtBQUtDLE1BQU0sS0FBSztZQUN2QyxLQUFLO2dCQUNILE9BQU8sY0FBY0QsS0FBS0MsTUFBTSxLQUFLO1lBQ3ZDO2dCQUNFLE9BQU8sY0FBY0QsS0FBS0MsTUFBTSxLQUFLO1FBQ3pDO0lBQ0Y7SUFFUWhELGdCQUFnQnJCLE1BQWMsRUFBVTtRQUM5QyxPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRVF1QixtQkFBbUJ2QixNQUFjLEVBQVU7UUFDakQsT0FBUUE7WUFDTixLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVRdUMsc0JBQXNCdkMsTUFBYyxFQUFFc0UsS0FBaUMsRUFBWTtRQUN6RixNQUFNQyxTQUFTO1FBQ2YsTUFBTUMsU0FBbUIsRUFBRTtRQUMzQixJQUFJQyxRQUFRO1FBRVosSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFHLElBQUs7WUFDL0IsSUFBSUosVUFBVSxNQUFNO2dCQUNsQix1Q0FBdUM7Z0JBQ3ZDRyxRQUFRQSxRQUFTLEtBQUtMLENBQUFBLEtBQUtDLE1BQU0sS0FBSyxPQUFPLElBQUcsQ0FBQztZQUNuRCxPQUFPLElBQUlDLFVBQVUsUUFBUTtnQkFDM0IseUNBQXlDO2dCQUN6Q0csUUFBUUEsUUFBUyxLQUFLTCxDQUFBQSxLQUFLQyxNQUFNLEtBQUssT0FBTyxJQUFHLENBQUM7WUFDbkQsT0FBTztnQkFDTCxvQ0FBb0M7Z0JBQ3BDSSxRQUFRQSxRQUFTLEtBQUtMLENBQUFBLEtBQUtDLE1BQU0sS0FBSyxPQUFPLElBQUcsQ0FBQztZQUNuRDtZQUNBRyxPQUFPRyxJQUFJLENBQUNGO1FBQ2Q7UUFFQSxPQUFPRDtJQUNUOzthQW5OUXhCLFlBQThCO2FBQzlCRixVQUFvQmhELFlBQVlhLEdBQUcsQ0FBQyxDQUFDQyxTQUFXLEdBQStCLE9BQTVCQSxPQUFPWixNQUFNLENBQUNxQyxXQUFXLElBQUc7O0FBbU56RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFw5MTYyOVxcRG93bmxvYWRzXFxjcnlwdG8tZGFzaGJvYXJkXFxsaWJcXHNlcnZpY2VzXFxiaW5hbmNlLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDcnlwdG9EYXRhIH0gZnJvbSBcIkAvbGliL3R5cGVzXCJcblxuLy8gVG9wIGNyeXB0b2N1cnJlbmNpZXMgdG8gdHJhY2tcbmNvbnN0IFRPUF9DUllQVE9TID0gW1xuICB7IGlkOiBcImJpdGNvaW5cIiwgc3ltYm9sOiBcIkJUQ1wiLCBuYW1lOiBcIkJpdGNvaW5cIiwgaW1hZ2U6IFwiYnRjXCIgfSxcbiAgeyBpZDogXCJldGhlcmV1bVwiLCBzeW1ib2w6IFwiRVRIXCIsIG5hbWU6IFwiRXRoZXJldW1cIiwgaW1hZ2U6IFwiL2NyeXB0by1pY29ucy9ldGgucG5nXCIgfSxcbiAgeyBpZDogXCJ0ZXRoZXJcIiwgc3ltYm9sOiBcIlVTRFRcIiwgbmFtZTogXCJUZXRoZXJcIiwgaW1hZ2U6IFwiL2NyeXB0by1pY29ucy91c2R0LnBuZ1wiIH0sXG4gIHsgaWQ6IFwicmlwcGxlXCIsIHN5bWJvbDogXCJYUlBcIiwgbmFtZTogXCJYUlBcIiwgaW1hZ2U6IFwiL2NyeXB0by1pY29ucy94cnAucG5nXCIgfSxcbiAgeyBpZDogXCJiaW5hbmNlY29pblwiLCBzeW1ib2w6IFwiQk5CXCIsIG5hbWU6IFwiQk5CXCIsIGltYWdlOiBcIi9jcnlwdG8taWNvbnMvYm5iLnBuZ1wiIH0sXG4gIHsgaWQ6IFwic29sYW5hXCIsIHN5bWJvbDogXCJTT0xcIiwgbmFtZTogXCJTb2xhbmFcIiwgaW1hZ2U6IFwiL2NyeXB0by1pY29ucy9zb2wucG5nXCIgfSxcbl1cblxuZXhwb3J0IGNsYXNzIEJpbmFuY2VTZXJ2aWNlIHtcbiAgcHJpdmF0ZSB3ZWJzb2NrZXQ6IFdlYlNvY2tldCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgc3ltYm9sczogc3RyaW5nW10gPSBUT1BfQ1JZUFRPUy5tYXAoKGNyeXB0bykgPT4gYCR7Y3J5cHRvLnN5bWJvbC50b0xvd2VyQ2FzZSgpfXVzZHRgKVxuXG4gIC8vIEZldGNoIGluaXRpYWwgY3J5cHRvIGRhdGFcbiAgYXN5bmMgZ2V0Q3J5cHRvRGF0YSgpOiBQcm9taXNlPENyeXB0b0RhdGFbXT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGZXRjaCBjdXJyZW50IHByaWNlc1xuICAgICAgY29uc3QgcHJpY2VSZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzL3RpY2tlci9wcmljZVwiKVxuICAgICAgY29uc3QgcHJpY2VEYXRhID0gYXdhaXQgcHJpY2VSZXNwb25zZS5qc29uKClcblxuICAgICAgLy8gRmV0Y2ggMjRoIHN0YXRzXG4gICAgICBjb25zdCBzdGF0c1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjMvdGlja2VyLzI0aHJcIilcbiAgICAgIGNvbnN0IHN0YXRzRGF0YSA9IGF3YWl0IHN0YXRzUmVzcG9uc2UuanNvbigpXG5cbiAgICAgIC8vIE1hcCB0aGUgZGF0YSB0byBvdXIgZm9ybWF0XG4gICAgICByZXR1cm4gVE9QX0NSWVBUT1MubWFwKChjcnlwdG8pID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gYCR7Y3J5cHRvLnN5bWJvbH1VU0RUYFxuICAgICAgICBjb25zdCBwcmljZSA9IHByaWNlRGF0YS5maW5kKChwOiBhbnkpID0+IHAuc3ltYm9sID09PSBzeW1ib2wpXG4gICAgICAgIGNvbnN0IHN0YXRzID0gc3RhdHNEYXRhLmZpbmQoKHM6IGFueSkgPT4gcy5zeW1ib2wgPT09IHN5bWJvbClcblxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gZGF0YSBmb3IgZmllbGRzIG5vdCBhdmFpbGFibGUgZnJvbSBCaW5hbmNlIEFQSVxuICAgICAgICBjb25zdCBtYXJrZXRDYXAgPSB0aGlzLmdldFJhbmRvbU1hcmtldENhcChjcnlwdG8uc3ltYm9sKVxuICAgICAgICBjb25zdCBjaXJjdWxhdGluZ1N1cHBseSA9IHRoaXMuZ2V0UmFuZG9tU3VwcGx5KGNyeXB0by5zeW1ib2wpXG4gICAgICAgIGNvbnN0IG1heFN1cHBseSA9XG4gICAgICAgICAgY3J5cHRvLnN5bWJvbCA9PT0gXCJCVENcIiA/IDIxMDAwMDAwIDogY3J5cHRvLnN5bWJvbCA9PT0gXCJFVEhcIiA/IDAgOiB0aGlzLmdldFJhbmRvbU1heFN1cHBseShjcnlwdG8uc3ltYm9sKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGNyeXB0by5pZCxcbiAgICAgICAgICBuYW1lOiBjcnlwdG8ubmFtZSxcbiAgICAgICAgICBzeW1ib2w6IGNyeXB0by5zeW1ib2wsXG4gICAgICAgICAgaW1hZ2U6IGNyeXB0by5pbWFnZSxcbiAgICAgICAgICBwcmljZTogTnVtYmVyLnBhcnNlRmxvYXQocHJpY2U/LnByaWNlIHx8IFwiMFwiKSxcbiAgICAgICAgICBwcmljZUNoYW5nZTFoOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMC41KSxcbiAgICAgICAgICBwcmljZUNoYW5nZTI0aDogc3RhdHMgPyBOdW1iZXIucGFyc2VGbG9hdChzdGF0cy5wcmljZUNoYW5nZVBlcmNlbnQpIDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDIpLFxuICAgICAgICAgIHByaWNlQ2hhbmdlN2Q6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSg1KSxcbiAgICAgICAgICBtYXJrZXRDYXAsXG4gICAgICAgICAgdm9sdW1lMjRoOiBzdGF0cyA/IE51bWJlci5wYXJzZUZsb2F0KHN0YXRzLnF1b3RlVm9sdW1lKSA6IHRoaXMuZ2V0UmFuZG9tVm9sdW1lKCksXG4gICAgICAgICAgdm9sdW1lMjRoSW5DcnlwdG86IHN0YXRzXG4gICAgICAgICAgICA/IE51bWJlci5wYXJzZUZsb2F0KHN0YXRzLnZvbHVtZSlcbiAgICAgICAgICAgIDogdGhpcy5nZXRSYW5kb21Wb2x1bWUoKSAvIE51bWJlci5wYXJzZUZsb2F0KHByaWNlPy5wcmljZSB8fCBcIjFcIiksXG4gICAgICAgICAgY2lyY3VsYXRpbmdTdXBwbHksXG4gICAgICAgICAgbWF4U3VwcGx5LFxuICAgICAgICAgIHNwYXJrbGluZTdkOiBgL2NyeXB0by1jaGFydHMvJHtjcnlwdG8uc3ltYm9sLnRvTG93ZXJDYXNlKCl9LnN2Z2AsXG4gICAgICAgICAgc3BhcmtsaW5lRGF0YTogdGhpcy5nZW5lcmF0ZVNwYXJrbGluZURhdGEoXG4gICAgICAgICAgICBjcnlwdG8uc3ltYm9sLFxuICAgICAgICAgICAgY3J5cHRvLnN5bWJvbCA9PT0gXCJCVENcIiB8fCBjcnlwdG8uc3ltYm9sID09PSBcIkVUSFwiIHx8IGNyeXB0by5zeW1ib2wgPT09IFwiU09MXCJcbiAgICAgICAgICAgICAgPyBcInVwXCJcbiAgICAgICAgICAgICAgOiBjcnlwdG8uc3ltYm9sID09PSBcIlVTRFRcIlxuICAgICAgICAgICAgICAgID8gXCJ2b2xhdGlsZVwiXG4gICAgICAgICAgICAgICAgOiBcInVwXCIsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpc0Zhdm9yaXRlOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNyeXB0byBkYXRhOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhcnQgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHJlYWwtdGltZSB1cGRhdGVzXG4gIHN0YXJ0UmVhbFRpbWVVcGRhdGVzKGNhbGxiYWNrOiAodXBkYXRlOiBQYXJ0aWFsPENyeXB0b0RhdGE+ICYgeyBpZDogc3RyaW5nIH0pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgICAvLyBDcmVhdGUgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBCaW5hbmNlXG4gICAgY29uc3Qgc3RyZWFtcyA9IHRoaXMuc3ltYm9scy5tYXAoKHN5bWJvbCkgPT4gYCR7c3ltYm9sfUB0aWNrZXJgKS5qb2luKFwiL1wiKVxuICAgIHRoaXMud2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldChgd3NzOi8vc3RyZWFtLmJpbmFuY2UuY29tOjk0NDMvd3MvJHtzdHJlYW1zfWApXG5cbiAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG5cbiAgICAgIC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgY3J5cHRvXG4gICAgICBjb25zdCBzeW1ib2wgPSBkYXRhLnMucmVwbGFjZShcIlVTRFRcIiwgXCJcIilcbiAgICAgIGNvbnN0IGNyeXB0byA9IFRPUF9DUllQVE9TLmZpbmQoKGMpID0+IGMuc3ltYm9sID09PSBzeW1ib2wpXG5cbiAgICAgIGlmIChjcnlwdG8pIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjcnlwdG8gZGF0YVxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgaWQ6IGNyeXB0by5pZCxcbiAgICAgICAgICBwcmljZTogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS5jKSxcbiAgICAgICAgICBwcmljZUNoYW5nZTI0aDogTnVtYmVyLnBhcnNlRmxvYXQoZGF0YS5QKSxcbiAgICAgICAgICBwcmljZUNoYW5nZTFoOiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoMC4zKSwgLy8gU2ltdWxhdGUgMWggY2hhbmdlXG4gICAgICAgICAgdm9sdW1lMjRoOiBOdW1iZXIucGFyc2VGbG9hdChkYXRhLnEpLFxuICAgICAgICAgIHZvbHVtZTI0aEluQ3J5cHRvOiBOdW1iZXIucGFyc2VGbG9hdChkYXRhLnYpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMud2Vic29ja2V0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJXZWJTb2NrZXQgZXJyb3I6XCIsIGVycm9yKVxuICAgICAgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiBXZWJTb2NrZXQgZmFpbHNcbiAgICAgIHRoaXMuc3RhcnRQb2xsaW5nKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIFdlYlNvY2tldFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGhpcy53ZWJzb2NrZXQpIHtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoKVxuICAgICAgICB0aGlzLndlYnNvY2tldCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGYWxsYmFjayB0byBwb2xsaW5nIGlmIFdlYlNvY2tldCBpcyBub3QgYXZhaWxhYmxlXG4gIHByaXZhdGUgc3RhcnRQb2xsaW5nKGNhbGxiYWNrOiAodXBkYXRlOiBQYXJ0aWFsPENyeXB0b0RhdGE+ICYgeyBpZDogc3RyaW5nIH0pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByaWNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLmJpbmFuY2UuY29tL2FwaS92My90aWNrZXIvcHJpY2VcIilcbiAgICAgICAgY29uc3QgcHJpY2VEYXRhID0gYXdhaXQgcHJpY2VSZXNwb25zZS5qc29uKClcblxuICAgICAgICBUT1BfQ1JZUFRPUy5mb3JFYWNoKChjcnlwdG8pID0+IHtcbiAgICAgICAgICBjb25zdCBzeW1ib2wgPSBgJHtjcnlwdG8uc3ltYm9sfVVTRFRgXG4gICAgICAgICAgY29uc3QgcHJpY2UgPSBwcmljZURhdGEuZmluZCgocDogYW55KSA9PiBwLnN5bWJvbCA9PT0gc3ltYm9sKVxuXG4gICAgICAgICAgaWYgKHByaWNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgIGlkOiBjcnlwdG8uaWQsXG4gICAgICAgICAgICAgIHByaWNlOiBOdW1iZXIucGFyc2VGbG9hdChwcmljZS5wcmljZSksXG4gICAgICAgICAgICAgIHByaWNlQ2hhbmdlMWg6IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgwLjMpLFxuICAgICAgICAgICAgICBwcmljZUNoYW5nZTI0aDogdGhpcy5nZXRSYW5kb21QZXJjZW50YWdlKDEpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcG9sbGluZyBjcnlwdG8gZGF0YTpcIiwgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgMjAwMClcblxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKVxuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHMgdG8gZ2VuZXJhdGUgcmFuZG9tIGRhdGFcbiAgcHJpdmF0ZSBnZXRSYW5kb21QZXJjZW50YWdlKG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIG1heCAqIDIgLSBtYXhcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmFuZG9tVm9sdW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5kb21NYXJrZXRDYXAoc3ltYm9sOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICBjYXNlIFwiQlRDXCI6XG4gICAgICAgIHJldHVybiAxODAwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwMFxuICAgICAgY2FzZSBcIkVUSFwiOlxuICAgICAgICByZXR1cm4gMjEwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwXG4gICAgICBjYXNlIFwiVVNEVFwiOlxuICAgICAgICByZXR1cm4gMTQwMDAwMDAwMDAwICsgTWF0aC5yYW5kb20oKSAqIDUwMDAwMDAwMDBcbiAgICAgIGNhc2UgXCJYUlBcIjpcbiAgICAgICAgcmV0dXJuIDEzMDAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiA1MDAwMDAwMDAwXG4gICAgICBjYXNlIFwiQk5CXCI6XG4gICAgICAgIHJldHVybiA4NTAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAyMDAwMDAwMDAwXG4gICAgICBjYXNlIFwiU09MXCI6XG4gICAgICAgIHJldHVybiA3ODAwMDAwMDAwMCArIE1hdGgucmFuZG9tKCkgKiAyMDAwMDAwMDAwXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMTAwMDAwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmFuZG9tU3VwcGx5KHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBcIkJUQ1wiOlxuICAgICAgICByZXR1cm4gMTk4NTAwMDBcbiAgICAgIGNhc2UgXCJFVEhcIjpcbiAgICAgICAgcmV0dXJuIDEyMDcxMDAwMFxuICAgICAgY2FzZSBcIlVTRFRcIjpcbiAgICAgICAgcmV0dXJuIDE0NTI3MDAwMDAwMFxuICAgICAgY2FzZSBcIlhSUFwiOlxuICAgICAgICByZXR1cm4gNTgzOTAwMDAwMDBcbiAgICAgIGNhc2UgXCJCTkJcIjpcbiAgICAgICAgcmV0dXJuIDE0MDg5MDAwMFxuICAgICAgY2FzZSBcIlNPTFwiOlxuICAgICAgICByZXR1cm4gNTE3MzEwMDAwXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMTAwMDAwMDAwMFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmFuZG9tTWF4U3VwcGx5KHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBcIkJUQ1wiOlxuICAgICAgICByZXR1cm4gMjEwMDAwMDBcbiAgICAgIGNhc2UgXCJYUlBcIjpcbiAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDAwMFxuICAgICAgY2FzZSBcIkJOQlwiOlxuICAgICAgICByZXR1cm4gMjAwMDAwMDAwXG4gICAgICBjYXNlIFwiU09MXCI6XG4gICAgICAgIHJldHVybiA3MDAwMDAwMDBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVNwYXJrbGluZURhdGEoc3ltYm9sOiBzdHJpbmcsIHRyZW5kOiBcInVwXCIgfCBcImRvd25cIiB8IFwidm9sYXRpbGVcIik6IG51bWJlcltdIHtcbiAgICBjb25zdCBsZW5ndGggPSAyNFxuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXVxuICAgIGxldCB2YWx1ZSA9IDEwMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZW5kID09PSBcInVwXCIpIHtcbiAgICAgICAgLy8gVXB3YXJkIHRyZW5kIHdpdGggc21hbGwgZmx1Y3R1YXRpb25zXG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4wMyAtIDAuMDEpKVxuICAgICAgfSBlbHNlIGlmICh0cmVuZCA9PT0gXCJkb3duXCIpIHtcbiAgICAgICAgLy8gRG93bndhcmQgdHJlbmQgd2l0aCBzbWFsbCBmbHVjdHVhdGlvbnNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqICgxICsgKE1hdGgucmFuZG9tKCkgKiAwLjAyIC0gMC4wMykpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWb2xhdGlsZSB3aXRoIGxhcmdlciBmbHVjdHVhdGlvbnNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqICgxICsgKE1hdGgucmFuZG9tKCkgKiAwLjA4IC0gMC4wNCkpXG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJUT1BfQ1JZUFRPUyIsImlkIiwic3ltYm9sIiwibmFtZSIsImltYWdlIiwiQmluYW5jZVNlcnZpY2UiLCJnZXRDcnlwdG9EYXRhIiwicHJpY2VSZXNwb25zZSIsImZldGNoIiwicHJpY2VEYXRhIiwianNvbiIsInN0YXRzUmVzcG9uc2UiLCJzdGF0c0RhdGEiLCJtYXAiLCJjcnlwdG8iLCJwcmljZSIsImZpbmQiLCJwIiwic3RhdHMiLCJzIiwibWFya2V0Q2FwIiwiZ2V0UmFuZG9tTWFya2V0Q2FwIiwiY2lyY3VsYXRpbmdTdXBwbHkiLCJnZXRSYW5kb21TdXBwbHkiLCJtYXhTdXBwbHkiLCJnZXRSYW5kb21NYXhTdXBwbHkiLCJOdW1iZXIiLCJwYXJzZUZsb2F0IiwicHJpY2VDaGFuZ2UxaCIsImdldFJhbmRvbVBlcmNlbnRhZ2UiLCJwcmljZUNoYW5nZTI0aCIsInByaWNlQ2hhbmdlUGVyY2VudCIsInByaWNlQ2hhbmdlN2QiLCJ2b2x1bWUyNGgiLCJxdW90ZVZvbHVtZSIsImdldFJhbmRvbVZvbHVtZSIsInZvbHVtZTI0aEluQ3J5cHRvIiwidm9sdW1lIiwic3BhcmtsaW5lN2QiLCJ0b0xvd2VyQ2FzZSIsInNwYXJrbGluZURhdGEiLCJnZW5lcmF0ZVNwYXJrbGluZURhdGEiLCJpc0Zhdm9yaXRlIiwiZXJyb3IiLCJjb25zb2xlIiwic3RhcnRSZWFsVGltZVVwZGF0ZXMiLCJjYWxsYmFjayIsInN0cmVhbXMiLCJzeW1ib2xzIiwiam9pbiIsIndlYnNvY2tldCIsIldlYlNvY2tldCIsIm9ubWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsInJlcGxhY2UiLCJjIiwiUCIsInEiLCJ2Iiwib25lcnJvciIsInN0YXJ0UG9sbGluZyIsImNsb3NlIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImZvckVhY2giLCJjbGVhckludGVydmFsIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsInRyZW5kIiwibGVuZ3RoIiwicmVzdWx0IiwidmFsdWUiLCJpIiwicHVzaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/binance-service.ts\n"));

/***/ })

});